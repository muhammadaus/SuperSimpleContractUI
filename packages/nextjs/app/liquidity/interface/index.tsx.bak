"use client";

import React, { useEffect, useState } from 'react';
import { isAddress, parseEther, formatEther, encodeFunctionData, Address } from 'viem';
import * as viemChains from 'viem/chains';
import { ethers } from 'ethers';
import { useTargetNetwork } from '../../../hooks/scaffold-eth/useTargetNetwork';
import { useContractStore } from "../../../utils/scaffold-eth/contract";
import { setContracts } from '../../../utils/scaffold-eth/contract';
import { notification } from "../../../utils/scaffold-eth/notification";
import { 
  useAppKit, 
  useAppKitAccount, 
  useAppKitProvider, 
  useAppKitNetwork,
  useDisconnect,
  createAppKit
} from '@reown/appkit/react';
import { EthersAdapter } from '@reown/appkit-adapter-ethers';
import type { AppKitNetwork } from '@reown/appkit/networks';

// Initialize AppKit at module level
if (typeof window !== 'undefined' && !(window as any).__APPKIT_INITIALIZED__) {
  try {
    console.log('Initializing AppKit in Liquidity Pool interface...');
    // Project metadata
    const metadata = {
      name: 'WrapTX Liquidity',
      description: 'Create and manage liquidity pools',
      url: 'https://reown.net',
      icons: ['https://reown.net/images/logo.png'],
    };
    
    // WalletConnect project ID (get from environment or use placeholder)
    const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID || 'YOUR_PROJECT_ID';
    
    // Create ethers adapter
    const ethersAdapter = new EthersAdapter();
    
    // Generate AppKit networks from all available viem chains
    const viemChainsArray = Object.values(viemChains).filter(
      (chain): chain is typeof viemChains.mainnet => 
        typeof chain === 'object' && 
        chain !== null && 
        'id' in chain && 
        typeof chain.id === 'number'
    );
    
    // Convert viem chains to AppKit networks
    const appKitNetworks: AppKitNetwork[] = viemChainsArray.map(chain => ({
      id: chain.id,
      name: chain.name || `Chain ${chain.id}`,
      rpcUrls: {
        default: {
          http: chain.rpcUrls?.default?.http || [`https://rpc.ankr.com/${chain.id}`]
        }
      },
      nativeCurrency: {
        name: chain.nativeCurrency?.name || 'Ether',
        symbol: chain.nativeCurrency?.symbol || 'ETH',
        decimals: chain.nativeCurrency?.decimals || 18,
      },
      blockExplorers: chain.blockExplorers?.default 
        ? {
            default: {
              url: chain.blockExplorers.default.url,
              name: chain.blockExplorers.default.name || 'Explorer'
            }
          }
        : {
            default: {
              url: `https://etherscan.io`,
              name: 'Explorer'
            }
          }
    }));
    
    // Ensure we have at least mainnet as the first item
    const mainnetNetwork = appKitNetworks.find(n => n.id === 1);
    if (mainnetNetwork) {
      // Move mainnet to the beginning of the array
      const filteredNetworks = appKitNetworks.filter(n => n.id !== 1);
      const networks = [mainnetNetwork, ...filteredNetworks] as [AppKitNetwork, ...AppKitNetwork[]];
      
      console.log(`Initializing AppKit with ${networks.length} networks`);
      console.log('Networks included:', networks.map(n => `${n.name} (${n.id})`).slice(0, 5), '...');
      
      createAppKit({
        adapters: [ethersAdapter],
        networks,
        metadata,
        projectId,
        themeMode: 'dark',
        features: {
          analytics: true,
        },
        themeVariables: {
          // Theme customization if needed
        },
      });
    } else {
      throw new Error("Mainnet network not found in viem chains");
    }
    
    // Mark as initialized
    (window as any).__APPKIT_INITIALIZED__ = true;
    console.log('AppKit initialized in Liquidity Pool interface');
  } catch (error) {
    console.error('Error initializing AppKit:', error);
  }
}

// Add utility functions for price and tick calculations
// Using multiplication instead of exponentiation for BigInt
const Q96 = BigInt('79228162514264337593543950336'); // 2^96

// Convert price to sqrtPriceX96
const priceToSqrtPriceX96 = (price: number): string => {
  // price = token1/token0
  // sqrtPriceX96 = sqrt(price) * 2^96
  const sqrtPrice = Math.sqrt(price);
  const sqrtPriceX96 = BigInt(Math.floor(sqrtPrice * Number(Q96)));
  return sqrtPriceX96.toString();
};

// Convert sqrtPriceX96 to price
const sqrtPriceX96ToPrice = (sqrtPriceX96: bigint): number => {
  // Convert back to a normal number
  const price = (Number(sqrtPriceX96) / Number(Q96)) ** 2;
  return price;
};

// Get tick from price
const getTickFromPrice = (price: number): number => {
  // tick = log(price) / log(1.0001)
  return Math.floor(Math.log(price) / Math.log(1.0001));
};

// Get price from tick
const getPriceFromTick = (tick: number): number => {
  // price = 1.0001^tick
  return 1.0001 ** tick;
};

// Get tick spacing based on fee
const getTickSpacingFromFee = (fee: number): number => {
  switch (fee) {
    case 100: // 0.01%
      return 1;
    case 500: // 0.05%
      return 10;
    case 3000: // 0.3%
      return 60;
    case 10000: // 1%
      return 200;
    default:
      return 60; // Default
  }
};

// Add this constant at the top with other constants
const NATIVE_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000'; // ADDRESS_ZERO for native token (ETH)

// Add these constants at the top with the other constants
const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'; // Standard Permit2 contract address

// Position Manager ABI - just the multicall function we need
const V4_POSITION_MANAGER_ABI = [
  {
    "inputs": [{"internalType": "bytes[]", "name": "data", "type": "bytes[]"}],
    "name": "multicall",
    "outputs": [{"internalType": "bytes[]", "name": "results", "type": "bytes[]"}],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {"internalType": "bytes", "name": "data", "type": "bytes"},
      {"internalType": "uint256", "name": "deadline", "type": "uint256"}
    ],
    "name": "modifyLiquidities",
    "outputs": [{"internalType": "bytes", "name": "", "type": "bytes"}],
    "stateMutability": "payable",
    "type": "function"
  }
];

// Custom hook to get V4 Position Manager contract
const useV4NFTPositionManagerContract = (
  address: string | undefined,
  withSigner = true
): ethers.Contract | null => {
  const [contract, setContract] = useState<ethers.Contract | null>(null);

  useEffect(() => {
    const getContract = async () => {
      if (!address || !isAddress(address)) {
        setContract(null);
        return;
      }

      try {
        // Get provider from window.ethereum
        if (!window.ethereum) {
          console.error("No provider available");
          return null;
        }
        
        const provider = new ethers.BrowserProvider(window.ethereum);
        
        // If we need a signer, connect to the account
        if (withSigner) {
          const signer = await provider.getSigner();
          const newContract = new ethers.Contract(
            address,
            V4_POSITION_MANAGER_ABI,
            signer
          );
          setContract(newContract);
        } else {
          const newContract = new ethers.Contract(
            address,
            V4_POSITION_MANAGER_ABI,
            provider
          );
          setContract(newContract);
        }
      } catch (error) {
        console.error("Failed to create contract:", error);
        setContract(null);
      }
    };

    getContract();
  }, [address, withSigner]);

  return contract;
};

export default function LiquidityPoolInterface() {
  // State variables for pool creation
  const [token0Address, setToken0Address] = useState<string>('');
  const [token1Address, setToken1Address] = useState<string>('');
  const [useNativeToken, setUseNativeToken] = useState<boolean>(false);
  const [fee, setFee] = useState<string>('500'); // Default 0.05% fee
  const [tickSpacing, setTickSpacing] = useState<number>(10); // Will be calculated based on fee
  const [hooksAddress, setHooksAddress] = useState<string>('0x0000000000000000000000000000000000000000');
  
  // Price inputs instead of sqrtPriceX96
  const [initialPrice, setInitialPrice] = useState<string>('1'); // Direct price input (token1/token0)
  const [initialSqrtPriceX96, setInitialSqrtPriceX96] = useState<string>('79228162514264337593543950336'); // Default price of 1:1
  
  // Price range inputs instead of ticks
  const [minPrice, setMinPrice] = useState<string>('0.5'); // 50% below the initial price
  const [maxPrice, setMaxPrice] = useState<string>('2'); // 100% above the initial price
  const [tickLower, setTickLower] = useState<number>(-6932); // Will be calculated from minPrice
  const [tickUpper, setTickUpper] = useState<number>(6935); // Will be calculated from maxPrice
  
  const [liquidityAmount, setLiquidityAmount] = useState<string>('');
  const [amount0, setAmount0] = useState<string>('');
  const [amount1, setAmount1] = useState<string>('');
  
  // Contract addresses
  const [poolManagerAddress, setPoolManagerAddress] = useState<string>('');
  const [positionManagerAddress, setPositionManagerAddress] = useState<string>('');
  
  // Step tracking
  const [poolInitialized, setPoolInitialized] = useState<boolean>(false);
  const [poolId, setPoolId] = useState<string>('');
  
  // Approval states
  const [isApproving, setIsApproving] = useState(false);
  const [token0Approved, setToken0Approved] = useState(false);
  const [token1Approved, setToken1Approved] = useState(false);
  
  // UI states
  const [isLoading, setIsLoading] = useState(false);
  const [txHash, setTxHash] = useState<string>('');
  const [encodedParams, setEncodedParams] = useState<{
    initialize: string;
    modifyLiquidity: string;
  }>({
    initialize: '',
    modifyLiquidity: '',
  });

  // Get user address from AppKit
  const { targetNetwork } = useTargetNetwork();
  const { isConnected, address: userAddress } = useAppKitAccount();
  const { open: openAppKit } = useAppKit();
  const { walletProvider } = useAppKitProvider<any>('eip155');
  const { chainId: currentChainId, switchNetwork } = useAppKitNetwork();
  const { disconnect } = useDisconnect();
  
  // Get contract data from the store
  const contracts = useContractStore(state => state.contracts);
  const poolManagerData = contracts?.[targetNetwork.id]?.LiquidityPoolManager;
  const positionManagerData = contracts?.[targetNetwork.id]?.PositionManager;

  // Debug log for contracts
  useEffect(() => {
    console.log("Target network ID:", targetNetwork.id);
    console.log("All contracts in store:", contracts);
    
    if (contracts && targetNetwork.id) {
      const networkContracts = contracts[targetNetwork.id];
      console.log("Contracts for current network:", networkContracts);
      
      if (networkContracts) {
        console.log("Keys in network contracts:", Object.keys(networkContracts));
        console.log("Position Manager exists:", !!networkContracts.PositionManager);
        console.log("Position Manager data:", networkContracts.PositionManager);
      }
    }
  }, [contracts, targetNetwork.id]);

  // Effect to handle native token selection
  useEffect(() => {
    if (useNativeToken) {
      setToken0Address(NATIVE_TOKEN_ADDRESS);
    } else if (token0Address === NATIVE_TOKEN_ADDRESS) {
      // Clear if no longer using native token
      setToken0Address('');
    }
  }, [useNativeToken]);

  // Update tick spacing when fee changes
  useEffect(() => {
    const feeValue = parseInt(fee);
    const newTickSpacing = getTickSpacingFromFee(feeValue);
    setTickSpacing(newTickSpacing);
  }, [fee]);

  // Update sqrtPriceX96 when initialPrice changes
  useEffect(() => {
    if (initialPrice && !isNaN(parseFloat(initialPrice)) && parseFloat(initialPrice) > 0) {
      const price = parseFloat(initialPrice);
      const newSqrtPriceX96 = priceToSqrtPriceX96(price);
      setInitialSqrtPriceX96(newSqrtPriceX96);
    }
  }, [initialPrice]);

  // Update ticks when price range changes
  useEffect(() => {
    if (minPrice && maxPrice && 
        !isNaN(parseFloat(minPrice)) && !isNaN(parseFloat(maxPrice)) && 
        parseFloat(minPrice) > 0 && parseFloat(maxPrice) > 0) {
      
      const min = parseFloat(minPrice);
      const max = parseFloat(maxPrice);
      
      // Calculate ticks from price
      let newTickLower = getTickFromPrice(min);
      let newTickUpper = getTickFromPrice(max);
      
      // Adjust ticks to be multiples of tickSpacing
      newTickLower = Math.floor(newTickLower / tickSpacing) * tickSpacing;
      newTickUpper = Math.ceil(newTickUpper / tickSpacing) * tickSpacing;
      
      setTickLower(newTickLower);
      setTickUpper(newTickUpper);
    }
  }, [minPrice, maxPrice, tickSpacing]);

  // Effect to populate the contract addresses from the store if available
  useEffect(() => {
    if (poolManagerData?.address) {
      setPoolManagerAddress(poolManagerData.address);
    }
    
    if (positionManagerData?.address) {
      setPositionManagerAddress(positionManagerData.address);
    }
  }, [poolManagerData, positionManagerData]);
  
  // Manual loading of position manager if needed
  const handleManuallySetPositionManager = async () => {
    if (!isAddress(positionManagerAddress)) {
      notification.error("Please enter a valid Position Manager address");
      return;
    }
    
    console.log("Manually setting Position Manager address:", positionManagerAddress);
    notification.info("Position Manager address set manually");
    
    // If you have the ABI, you could set it in the contract store manually
    try {
      if (contracts && targetNetwork.id) {
        // Create a copy of the current contracts
        const updatedContracts = { ...contracts };
        
        // Make sure network exists
        if (!updatedContracts[targetNetwork.id]) {
          updatedContracts[targetNetwork.id] = {};
        }
        
        // Add position manager contract with a more complete minimal ABI
        // This ABI contains the key functions needed to identify it as a Position Manager
        const positionManagerAbi = [
          {
            "inputs": [
              {
                "internalType": "bytes[]",
                "name": "data",
                "type": "bytes[]"
              }
            ],
            "name": "multicall",
            "outputs": [
              {
                "internalType": "bytes[]",
                "name": "results",
                "type": "bytes[]"
              }
            ],
            "stateMutability": "payable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "bytes",
                "name": "actions",
                "type": "bytes"
              },
              {
                "internalType": "bytes[]",
                "name": "params",
                "type": "bytes[]"
              },
              {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
              }
            ],
            "name": "modifyLiquidities",
            "outputs": [
              {
                "internalType": "bytes",
                "name": "",
                "type": "bytes"
              }
            ],
            "stateMutability": "payable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "tuple",
                "name": "key",
                "type": "tuple",
                "components": [
                  {
                    "internalType": "address",
                    "name": "currency0",
                    "type": "address"
                  },
                  {
                    "internalType": "address",
                    "name": "currency1",
                    "type": "address"
                  },
                  {
                    "internalType": "uint24",
                    "name": "fee",
                    "type": "uint24"
                  },
                  {
                    "internalType": "int24",
                    "name": "tickSpacing",
                    "type": "int24"
                  },
                  {
                    "internalType": "address",
                    "name": "hooks",
                    "type": "address"
                  }
                ]
              },
              {
                "internalType": "int24",
                "name": "tickLower",
                "type": "int24"
              },
              {
                "internalType": "int24",
                "name": "tickUpper",
                "type": "int24"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              },
              {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
              }
            ],
            "name": "mint",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "stateMutability": "payable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "tuple",
                "name": "key",
                "type": "tuple",
                "components": [
                  {
                    "internalType": "address",
                    "name": "currency0",
                    "type": "address"
                  },
                  {
                    "internalType": "address",
                    "name": "currency1",
                    "type": "address"
                  },
                  {
                    "internalType": "uint24",
                    "name": "fee",
                    "type": "uint24"
                  },
                  {
                    "internalType": "int24",
                    "name": "tickSpacing",
                    "type": "int24"
                  },
                  {
                    "internalType": "address",
                    "name": "hooks",
                    "type": "address"
                  }
                ]
              },
              {
                "internalType": "int24",
                "name": "tickLower",
                "type": "int24"
              },
              {
                "internalType": "int24",
                "name": "tickUpper",
                "type": "int24"
              },
              {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              },
              {
                "internalType": "bytes",
                "name": "hookData",
                "type": "bytes"
              },
              {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
              }
            ],
            "name": "settleAndMint",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
              }
            ],
            "stateMutability": "payable",
            "type": "function"
          }
        ];
        
        // Set the contract in the store
        updatedContracts[targetNetwork.id].PositionManager = {
          address: positionManagerAddress as `0x${string}`,
          abi: positionManagerAbi,
          inheritedFunctions: {}
        };
        
        // Use the imported setContracts function
        await setContracts(updatedContracts);
        
        console.log("Manual position manager contract set:", updatedContracts[targetNetwork.id].PositionManager);
        
        // Verify it was set correctly
        setTimeout(() => {
          const refreshedContracts = useContractStore.getState().contracts;
          console.log("Refreshed contracts after manual set:", refreshedContracts);
          console.log("Position Manager in refreshed contracts:", refreshedContracts[targetNetwork.id]?.PositionManager);
        }, 500);
        
        notification.success("Position Manager contract manually added to store!");
      }
    } catch (error) {
      console.error("Error manually setting position manager:", error);
      notification.error("Failed to manually set Position Manager: " + (error as Error).message);
    }
  };

  // Effect to detect when both contracts are available and ready to use
  useEffect(() => {
    console.log("Contract status update:", {
      poolManager: !!poolManagerData, 
      positionManager: !!positionManagerData
    });
    
    // When both contracts are loaded, we can perform additional setup if needed
    if (poolManagerData && positionManagerData) {
      notification.success("Both contracts loaded successfully!");
    }
  }, [poolManagerData, positionManagerData]);
  
  // Determine if we have the necessary contracts
  const hasPoolManager = isAddress(poolManagerAddress);
  const hasPositionManager = isAddress(positionManagerAddress);

  const encodeInitializePoolParams = () => {
    // Validate inputs
    if (!isAddress(token0Address) || !isAddress(token1Address)) {
      notification.error("Invalid token addresses");
      return null;
    }

    if (parseInt(fee) <= 0) {
      notification.error("Fee must be greater than 0");
      return null;
    }

    if (!initialSqrtPriceX96 || BigInt(initialSqrtPriceX96) <= BigInt(0)) {
      notification.error("Initial price must be greater than 0");
      return null;
    }

    // Create pool key
    const poolKey = {
      currency0: token0Address,
      currency1: token1Address,
      fee: parseInt(fee),
      tickSpacing: tickSpacing,
      hooks: hooksAddress
    };

    try {
      console.log("Creating initialize pool params with:", {
        poolKey,
        sqrtPriceX96: initialSqrtPriceX96
      });

      // Build the ABI fragment for initialize
      return { poolKey, sqrtPriceX96: BigInt(initialSqrtPriceX96) };
    } catch (error) {
      console.error("Error encoding initialize pool params:", error);
      notification.error("Failed to encode initialize pool parameters");
      return null;
    }
  };

  const encodeModifyLiquidityParams = () => {
    // Validate inputs
    if (!isAddress(token0Address) || !isAddress(token1Address)) {
      notification.error("Invalid token addresses");
      return null;
    }

    if (parseInt(fee) <= 0) {
      notification.error("Fee must be greater than 0");
      return null;
    }

    if (!liquidityAmount || parseFloat(liquidityAmount) <= 0) {
      notification.error("Liquidity amount must be greater than 0");
      return null;
    }

    // Create pool key (same as for initialize)
    const poolKey = {
      currency0: token0Address,
      currency1: token1Address,
      fee: parseInt(fee),
      tickSpacing: tickSpacing,
      hooks: hooksAddress
    };

    // Create modify liquidity params
    const liquidityDelta = parseEther(liquidityAmount);
    const modifyParams = {
      tickLower: tickLower,
      tickUpper: tickUpper,
      liquidityDelta: liquidityDelta,
      salt: "0x0000000000000000000000000000000000000000000000000000000000000000" // Default salt
    };

    try {
      console.log("Creating modify liquidity params with:", {
        poolKey,
        params: modifyParams,
        hookData: "0x" // Empty hook data
      });

      return { poolKey, params: modifyParams, hookData: "0x" };
    } catch (error) {
      console.error("Error encoding modify liquidity params:", error);
      notification.error("Failed to encode modify liquidity parameters");
      return null;
    }
  };

  const handleApproveTokens = async () => {
    try {
      // Validations
      if (!isConnected || !userAddress) {
        notification.error("Please connect your wallet");
        return;
      }

      if (!isAddress(positionManagerAddress)) {
        notification.error("Invalid Position Manager address");
        return;
      }

      // Skip approval for native token (token0)
      const isToken0Native = token0Address === NATIVE_TOKEN_ADDRESS;
      
      setIsApproving(true);
      notification.info("Approving tokens...");

      // Create ethers provider from walletProvider properly
      if (!walletProvider) {
        notification.error("Wallet provider not available");
        setIsApproving(false);
        return;
      }
      
      console.log("Creating ethers provider from walletProvider:", walletProvider);
      const provider = new ethers.BrowserProvider(walletProvider);
      const signer = await provider.getSigner();
      console.log("Signer created successfully:", signer.address);

      // ERC20 ABI (minimal for approve)
      const erc20Abi = [
        "function approve(address spender, uint256 amount) returns (bool)"
      ];

      // First approve Permit2 as a spender for both tokens
      if (!isToken0Native) {
        notification.info("Approving token0 for Permit2...");
        const token0Contract = new ethers.Contract(token0Address, erc20Abi, signer);
        const tx1 = await token0Contract.approve(
          PERMIT2_ADDRESS, 
          ethers.MaxUint256
        );
        await tx1.wait();
        notification.success("Token0 approved for Permit2");
      }

      notification.info("Approving token1 for Permit2...");
      const token1Contract = new ethers.Contract(token1Address, erc20Abi, signer);
      const tx2 = await token1Contract.approve(
        PERMIT2_ADDRESS, 
        ethers.MaxUint256
      );
      await tx2.wait();
      notification.success("Token1 approved for Permit2");

      // Now approve Position Manager using Permit2
      const permit2Abi = [
        "function approve(address token, address spender, uint160 amount, uint48 expiration) external"
      ];
      const permit2Contract = new ethers.Contract(PERMIT2_ADDRESS, permit2Abi, signer);

      if (!isToken0Native) {
        notification.info("Approving token0 for Position Manager...");
        const tx3 = await permit2Contract.approve(
          token0Address,
          positionManagerAddress,
          BigInt('0xffffffffffffffffff'), // max uint160
          Number('0xffffffffffff')        // max uint48
        );
        await tx3.wait();
        notification.success("Token0 approved for Position Manager");
      }

      notification.info("Approving token1 for Position Manager...");
      const tx4 = await permit2Contract.approve(
        token1Address,
        positionManagerAddress,
        BigInt('0xffffffffffffffffff'), // max uint160
        Number('0xffffffffffff')        // max uint48
      );
      await tx4.wait();
      notification.success("Token1 approved for Position Manager");

      // Update approval states
      setToken0Approved(true);
      setToken1Approved(true);
      notification.success("All tokens approved successfully");
    } catch (error) {
      console.error("Error approving tokens:", error);
      notification.error("Failed to approve tokens: " + (error as Error).message);
    } finally {
      setIsApproving(false);
    }
  };

  const handleInitializePool = async () => {
    try {
      // Validate wallet connection
      console.log("Initializing pool...");
      console.log("Wallet connected:", isConnected);
      console.log("User address:", userAddress);
      
      if (!isConnected || !userAddress) {
        notification.error("Please connect your wallet");
        return;
      }
      
      // Validate contract address
      console.log("Pool Manager address:", poolManagerAddress);
      if (!isAddress(poolManagerAddress)) {
        notification.error("Invalid Pool Manager contract address");
        return;
      }
      
      // Validate token addresses
      console.log("Token0 address:", token0Address);
      console.log("Token1 address:", token1Address);
      if (!isAddress(token0Address) || !isAddress(token1Address)) {
        notification.error("Invalid token addresses");
        return;
      }
      
      console.log("All initial validation passed. Proceeding to initialize pool...");
      setIsLoading(true);
      
      // Encode the initialize parameters
      const initializeParams = encodeInitializePoolParams();
      if (!initializeParams) {
        setIsLoading(false);
        return;
      }
      
      // Create ethers provider from walletProvider properly
      if (!walletProvider) {
        notification.error("Wallet provider not available");
        setIsLoading(false);
        return;
      }
      
      console.log("Creating ethers provider from walletProvider:", walletProvider);
      const provider = new ethers.BrowserProvider(walletProvider);
      const signer = await provider.getSigner();
      console.log("Signer created successfully:", signer.address);
      
      // Simple ABI for the Pool Manager
      const poolManagerAbi = [
        "function initialize(tuple(address currency0, address currency1, uint24 fee, int24 tickSpacing, address hooks) key, uint160 sqrtPriceX96) external returns (int24)"
      ];
      
      const poolManagerContract = new ethers.Contract(poolManagerAddress, poolManagerAbi, signer);
      
      // Call initialize function
      console.log("Calling initialize with params:", initializeParams);
      
      const transaction = await poolManagerContract.initialize(
        initializeParams.poolKey,
        initializeParams.sqrtPriceX96
      );
      
      console.log("Transaction sent:", transaction.hash);
      setTxHash(transaction.hash);
      
      // Wait for confirmation
      notification.info("Transaction submitted. Waiting for confirmation...");
      const receipt = await transaction.wait();
      
      // Check if successful
      if (receipt && receipt.status === 1) {
        notification.success("Pool initialized successfully!");
        setPoolInitialized(true);
        
        // Try to extract pool ID from events if possible
        try {
          const initializeEvent = receipt.events?.find((event: any) => event.event === 'Initialize');
          if (initializeEvent && initializeEvent.args && initializeEvent.args.id) {
            setPoolId(initializeEvent.args.id);
            console.log("Pool ID:", initializeEvent.args.id);
          }
        } catch (error: any) {
          console.warn("Could not extract pool ID from events:", error);
        }
      } else {
        notification.error("Transaction failed. Please check the transaction details.");
      }
      
    } catch (error) {
      console.error("Error initializing pool:", error);
      notification.error("Failed to initialize pool: " + (error as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleAddLiquidity = async () => {
    if (!positionManagerAddress) {
      notification.error("Position Manager address is required");
      return;
    }

    try {
      console.log("Starting add liquidity process...");
      setIsLoading(true);

      if (!walletProvider) {
        notification.error("Wallet provider not available");
        return;
      }

      console.log("Creating ethers provider and getting signer...");
      const provider = new ethers.BrowserProvider(walletProvider);
      const signer = await provider.getSigner();
      console.log("Signer created successfully:", signer.address);

      // Calculate value to send (for native ETH if token0 is native)
      const valueToSend = token0Address === NATIVE_TOKEN_ADDRESS 
        ? ethers.parseEther(amount0) 
        : ethers.parseEther("0");
      console.log(`Value to send: ${valueToSend.toString()}`);

      // Format addresses to ensure they're valid checksummed addresses
      const token0 = ethers.getAddress(token0Address);
      const token1 = ethers.getAddress(token1Address);
      
      console.log("Token0 (checksummed):", token0);
      console.log("Token1 (checksummed):", token1);
      
      // Create the pool key with checksummed addresses
      const poolKey = {
        currency0: token0,
        currency1: token1,
        fee: parseInt(fee),
        tickSpacing: tickSpacing,
        hooks: ethers.getAddress(hooksAddress)
      };
      
      console.log("Pool key details:");
      console.log("- currency0:", poolKey.currency0);
      console.log("- currency1:", poolKey.currency1);
      console.log("- fee:", poolKey.fee);
      console.log("- tickSpacing:", poolKey.tickSpacing);
      console.log("- hooks:", poolKey.hooks);
      
      // Parameter values
      const liquidityBigInt = ethers.parseEther(liquidityAmount);
      const amount0Max = ethers.parseEther(amount0.toString());
      const amount1Max = ethers.parseEther(amount1.toString());
      
      console.log("Parameter values:");
      console.log("- Liquidity amount:", liquidityBigInt.toString());
      console.log("- Amount0 max:", amount0Max.toString());
      console.log("- Amount1 max:", amount1Max.toString());
      console.log("- tickLower:", tickLower);
      console.log("- tickUpper:", tickUpper);

      // ============ PREPARE MULTICALL TRANSACTION ============
      console.log("Preparing multicall transaction...");

      // 1. Create the ABI coder
      const abiCoder = ethers.AbiCoder.defaultAbiCoder();
      
      // 2. Set actions using Uint8Array for proper byte encoding
      const MINT_POSITION = 0x02;
      const SETTLE_PAIR = 0x0D;
      const actions = new Uint8Array([MINT_POSITION, SETTLE_PAIR]);
      console.log("Actions bytes:", ethers.hexlify(actions));
      
      // 3. Create deadline (1 hour from now)
      const deadline = Math.floor(Date.now() / 1000) + 3600;
      console.log("Deadline:", deadline);
      
      // 4. Create modifyLiquidities parameters (following the documentation format exactly)
      // First parameter: MINT_POSITION parameters
      const mintParams = abiCoder.encode(
        [
          "tuple(address,address,uint24,int24,address)",  // poolKey
          "int24",    // tickLower
          "int24",    // tickUpper
          "uint256",  // liquidity
          "uint128",  // amount0Max
          "uint128",  // amount1Max
          "address",  // recipient
          "bytes"     // hookData
        ],
        [
          [poolKey.currency0, poolKey.currency1, poolKey.fee, poolKey.tickSpacing, poolKey.hooks],
          tickLower,
          tickUpper,
          liquidityBigInt,
          amount0Max,
          amount1Max,
          signer.address, // recipient
          "0x" // hook data
        ]
      );
      
      // Second parameter: SETTLE_PAIR parameters
      const settleParams = abiCoder.encode(
        ["address", "address"], // currency0, currency1
        [poolKey.currency0, poolKey.currency1]
      );
      
      // Create the parameters array for modifyLiquidities as per documentation
      const params = [mintParams, settleParams];
      console.log("Params array created with length:", params.length);
      console.log("First param preview:", mintParams.substring(0, 66) + "...");
      console.log("Second param preview:", settleParams.substring(0, 66) + "...");
      
      // 5. Following the exact format from documentation:
      // modifyLiquidities(abi.encode(actions, params), deadline)
      const originalModifyLiquiditiesData = abiCoder.encode(
        ["bytes", "bytes[]", "uint256"],
        [ethers.hexlify(actions), params, deadline]
      );
      
      console.log("ModifyLiquidities data created with length:", originalModifyLiquiditiesData.length);
      
      // Create position manager contract directly instead of using the hook
      console.log("Creating position manager contract:", positionManagerAddress);
      try {
        const positionManagerContract = new ethers.Contract(
          positionManagerAddress,
          V4_POSITION_MANAGER_ABI,
          signer
        );
        console.log("Position manager contract created successfully");
        
        // 6. Prepare the call to the multicall function correctly
        console.log("Preparing multicall transaction...");
        
        // Format modifyLiquidities call as the FIRST parameter to multicall
        const modifyLiquiditiesCallWithSelector = abiCoder.encode(
          ["bytes", "uint256"],
          [ethers.hexlify(actions), deadline]
        );
        
        // Prepare final parameter array for multicall (should have 2 items like in working example)
        const multicallParams = [
          "0x67df4fde" + originalModifyLiquiditiesData.substring(2) // modifyLiquidities selector + data
        ];
        
        console.log("Multicall parameters count:", multicallParams.length);
        console.log("First parameter starts with:", multicallParams[0].substring(0, 10)); // Should show 0x67df4fde
        
        // Transaction options
        const txOptions = {
          value: valueToSend,
          gasLimit: ethers.parseUnits("20000000", "wei")
        };
        
        console.log("Transaction options:", {
          value: txOptions.value.toString(),
          gasLimit: txOptions.gasLimit.toString()
        });
        
        // Direct call to multicall using the Position Manager contract
        console.log("Calling multicall with formatted parameters...");
        
        // This is the working sample format
        const txResponse = await positionManagerContract.multicall(
          multicallParams,
          txOptions
        );
        
        console.log("Transaction submitted:", txResponse.hash);
        notification.success("Liquidity position creation transaction submitted");
        
        // Wait for transaction confirmation
        const receipt = await txResponse.wait();
        console.log("Transaction confirmed:", receipt);
        
        // Check if transaction was successful
        if (receipt && receipt.status === 1) {
          notification.success("Successfully added liquidity!");
          setTxHash(txResponse.hash);
        } else {
          console.error("Transaction failed with status:", receipt?.status);
          notification.error("Transaction failed. See console for details.");
        }
      } catch (secondError: any) {
        console.error("Second attempt also failed:", secondError);
        notification.error("Both transaction attempts failed: " + (secondError as Error).message);
      }
    } catch (error: any) {
      console.error("Error in handleAddLiquidity:", error);
      
      if (error.message) {
        if (error.message.includes("insufficient funds")) {
          notification.error("Insufficient funds for transaction");
        } else if (error.message.includes("user rejected")) {
          notification.error("Transaction rejected by user");
        } else if (error.message.includes("gas required exceeds")) {
          notification.error("Gas estimation failed: The transaction may require more gas than the block gas limit");
        } else {
          notification.error(error.message);
        }
      } else {
        notification.error("Failed to add liquidity. See console for details.");
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col items-center mt-10 max-w-4xl mx-auto p-5 bg-gray-900 rounded-lg shadow-md">
      <h1 className="text-3xl font-bold mb-6 text-white">Liquidity Pool Management</h1>
      
      {/* Contract Configuration Section */}
      <div className="w-full mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
        <h2 className="text-xl font-bold mb-4 text-white">Contract Configuration</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Pool Manager Address</span>
            </label>
            <input
              type="text"
              placeholder="Pool Manager contract address"
              className={`w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 ${poolManagerData?.address ? 'opacity-80 cursor-not-allowed' : ''}`}
              value={poolManagerAddress}
              onChange={(e) => setPoolManagerAddress(e.target.value)}
              readOnly={!!poolManagerData?.address}
            />
            {poolManagerData?.address && (
              <p className="text-xs mt-1 text-green-400">✓ Pool Manager loaded from contracts</p>
            )}
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Position Manager Address</span>
            </label>
            <input
              type="text"
              placeholder="Position Manager contract address"
              className={`w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 ${positionManagerData?.address ? 'opacity-80 cursor-not-allowed' : ''}`}
              value={positionManagerAddress}
              onChange={(e) => setPositionManagerAddress(e.target.value)}
              readOnly={!!positionManagerData?.address}
            />
            {positionManagerData?.address && (
              <p className="text-xs mt-1 text-green-400">✓ Position Manager loaded from contracts</p>
            )}
            {!positionManagerData?.address && isAddress(positionManagerAddress) && (
              <button
                className="mt-2 px-3 py-1 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 transition-colors"
                onClick={handleManuallySetPositionManager}
              >
                Register Position Manager
              </button>
            )}
          </div>
        </div>
      </div>
      
      {/* Pool Configuration Section */}
      <div className="w-full mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
        <h2 className="text-xl font-bold mb-4 text-white">Pool Configuration</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Token0</span>
              <span className="label-text-alt text-gray-400">
                <div className="form-control">
                  <label className="cursor-pointer label">
                    <span className="label-text mr-2 text-gray-400">Use Native Token</span> 
                    <input 
                      type="checkbox" 
                      className="toggle toggle-sm toggle-primary" 
                      checked={useNativeToken}
                      onChange={(e) => setUseNativeToken(e.target.checked)}
                    />
                  </label>
                </div>
              </span>
            </label>
            <input
              type="text"
              placeholder="Token0 address"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
              value={token0Address}
              onChange={(e) => !useNativeToken && setToken0Address(e.target.value)}
              disabled={useNativeToken}
            />
            {useNativeToken && (
              <p className="text-xs mt-1 text-blue-400">Using native token (ETH)</p>
            )}
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Token1</span>
            </label>
            <input
              type="text"
              placeholder="Token1 address"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={token1Address}
              onChange={(e) => setToken1Address(e.target.value)}
            />
          </div>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Fee</span>
            </label>
            <select
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={fee}
              onChange={(e) => setFee(e.target.value)}
            >
              <option value="100">0.01%</option>
              <option value="500">0.05%</option>
              <option value="3000">0.3%</option>
              <option value="10000">1%</option>
            </select>
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Tick Spacing</span>
            </label>
            <input
              type="number"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
              value={tickSpacing}
              disabled
            />
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Hooks Address</span>
            </label>
            <input
              type="text"
              placeholder="Hooks address"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={hooksAddress}
              onChange={(e) => setHooksAddress(e.target.value)}
            />
          </div>
        </div>
      </div>
      
      {/* Step 1: Initialize Pool */}
      <div className="w-full mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
        <h2 className="text-xl font-bold mb-4 text-white">Step 1: Initialize Pool</h2>
        <div className="grid grid-cols-1 gap-4">
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Initial Price (token1/token0)</span>
            </label>
            <input
              type="text"
              placeholder="Initial price"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={initialPrice}
              onChange={(e) => setInitialPrice(e.target.value)}
            />
            <div className="text-xs mt-1 text-gray-400">
              SqrtPriceX96: {initialSqrtPriceX96}
            </div>
          </div>
          
          <div className="mt-4">
            <button
              className={`px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-medium rounded-xl shadow-lg transition-all duration-200 w-full ${isLoading ? 'opacity-70 cursor-not-allowed' : ''}`}
              onClick={handleInitializePool}
              disabled={isLoading || !isConnected || !hasPoolManager || !isAddress(token0Address) || !isAddress(token1Address)}
            >
              {isLoading ? (
                <div className="flex items-center justify-center">
                  <div className="flex gap-1 mr-2">
                    <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '0ms' }}></div>
                    <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '150ms' }}></div>
                    <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '300ms' }}></div>
                  </div>
                  Initializing Pool...
                </div>
              ) : 'Initialize Pool'}
            </button>
          </div>
        </div>
        
        {poolInitialized && (
          <div className="mt-4 p-3 bg-green-900/50 border border-green-700 text-green-300 rounded-lg">
            Pool initialized successfully!
            {poolId && <div className="text-sm mt-2 font-mono">Pool ID: {poolId}</div>}
          </div>
        )}
      </div>
      
      {/* Step 2: Add Liquidity */}
      <div className="w-full mb-6 p-4 bg-gray-800 rounded-lg border border-gray-700">
        <h2 className="text-xl font-bold mb-4 text-white">Step 2: Add Liquidity</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Min Price</span>
            </label>
            <input
              type="text"
              placeholder="Minimum price"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={minPrice}
              onChange={(e) => setMinPrice(e.target.value)}
            />
            <div className="text-xs mt-1 text-gray-400">
              Tick Lower: {tickLower}
            </div>
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Max Price</span>
            </label>
            <input
              type="text"
              placeholder="Maximum price"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={maxPrice}
              onChange={(e) => setMaxPrice(e.target.value)}
            />
            <div className="text-xs mt-1 text-gray-400">
              Tick Upper: {tickUpper}
            </div>
          </div>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Liquidity Amount</span>
            </label>
            <input
              type="text"
              placeholder="Liquidity amount"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={liquidityAmount}
              onChange={(e) => setLiquidityAmount(e.target.value)}
            />
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Amount Token0</span>
            </label>
            <input
              type="text"
              placeholder="Amount of token0"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={amount0}
              onChange={(e) => setAmount0(e.target.value)}
            />
          </div>
          <div>
            <label className="label">
              <span className="label-text text-gray-300">Amount Token1</span>
            </label>
            <input
              type="text"
              placeholder="Amount of token1"
              className="w-full p-3 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={amount1}
              onChange={(e) => setAmount1(e.target.value)}
            />
          </div>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <button
            className={`px-6 py-3 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-xl shadow-lg transition-all duration-200 ${isApproving ? 'opacity-70 cursor-not-allowed' : ''}`}
            onClick={handleApproveTokens}
            disabled={isApproving || isLoading || !isConnected || !hasPositionManager || !isAddress(token0Address) || !isAddress(token1Address)}
          >
            {isApproving ? (
              <div className="flex items-center justify-center">
                <div className="flex gap-1 mr-2">
                  <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '0ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '150ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '300ms' }}></div>
                </div>
                Approving Tokens...
              </div>
            ) : 'Approve Tokens'}
          </button>
          
          <button
            className={`px-6 py-3 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-medium rounded-xl shadow-lg transition-all duration-200 ${isLoading ? 'opacity-70 cursor-not-allowed' : ''}`}
            onClick={handleAddLiquidity}
            disabled={
              isLoading || 
              !isConnected || 
              !hasPoolManager || 
              !hasPositionManager || 
              !poolInitialized || 
              ((!token0Approved && token0Address !== NATIVE_TOKEN_ADDRESS) || !token1Approved) ||
              !liquidityAmount
            }
          >
            {isLoading ? (
              <div className="flex items-center justify-center">
                <div className="flex gap-1 mr-2">
                  <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '0ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '150ms' }}></div>
                  <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '300ms' }}></div>
                </div>
                Adding Liquidity...
              </div>
            ) : 'Add Liquidity'}
          </button>
        </div>

        {/* Missing Requirements Indicators */}
        {isConnected && (
          <div className="mt-4">
            <h3 className="text-sm font-semibold mb-2 text-white">Requirements:</h3>
            <ul className="text-xs space-y-1">
              <li className={hasPoolManager ? 'text-green-400' : 'text-red-400'}>
                {hasPoolManager ? '✓' : '✗'} Pool Manager Contract
              </li>
              <li className={hasPositionManager ? 'text-green-400' : 'text-red-400'}>
                {hasPositionManager ? '✓' : '✗'} Position Manager Contract
              </li>
              <li className={poolInitialized ? 'text-green-400' : 'text-red-400'}>
                {poolInitialized ? '✓' : '✗'} Pool Initialized
              </li>
              <li className={token0Address === NATIVE_TOKEN_ADDRESS || token0Approved ? 'text-green-400' : 'text-red-400'}>
                {token0Address === NATIVE_TOKEN_ADDRESS || token0Approved ? '✓' : '✗'} Token0 Approved
              </li>
              <li className={token1Approved ? 'text-green-400' : 'text-red-400'}>
                {token1Approved ? '✓' : '✗'} Token1 Approved
              </li>
              <li className={!!liquidityAmount ? 'text-green-400' : 'text-red-400'}>
                {!!liquidityAmount ? '✓' : '✗'} Liquidity Amount Set
              </li>
            </ul>
          </div>
        )}
      </div>
      
      {/* Transaction Status */}
      {txHash && (
        <div className="w-full p-4 bg-gray-800 rounded-lg border border-gray-700">
          <h2 className="text-xl font-bold mb-2 text-white">Transaction</h2>
          <div className="break-all font-mono text-blue-400">
            <a 
              href={`${targetNetwork.blockExplorers?.default.url}/tx/${txHash}`} 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-blue-400 hover:text-blue-300 hover:underline"
            >
              {txHash}
            </a>
          </div>
        </div>
      )}
      
      {/* Connect Wallet */}
      {!isConnected && (
        <div className="w-full mt-6 p-4 bg-yellow-900/50 border border-yellow-700 text-yellow-300 rounded-lg">
          <div className="flex items-center justify-between">
            <span>Please connect your wallet to continue</span>
            <button 
              className="px-4 py-2 bg-yellow-700 hover:bg-yellow-600 text-white rounded-lg" 
              onClick={() => openAppKit()}
            >
              Connect Wallet
            </button>
          </div>
        </div>
      )}
      
      {/* Contract Loading Status */}
      {(!hasPoolManager || !hasPositionManager) && (
        <div className="w-full mt-6 p-4 bg-gray-800 rounded-lg border border-gray-700 text-gray-300">
          <h3 className="text-lg font-semibold mb-2 text-white">Contract Status</h3>
          <ul className="list-disc pl-5 space-y-1">
            <li className={hasPoolManager ? 'text-green-400' : 'text-yellow-400'}>
              Pool Manager: {hasPoolManager ? 'Loaded ✓' : 'Not loaded! Please enter a valid address.'}
            </li>
            <li className={hasPositionManager ? 'text-green-400' : 'text-yellow-400'}>
              Position Manager: {hasPositionManager ? 'Loaded ✓' : 'Not loaded! Please enter a valid address.'}
            </li>
          </ul>
          <p className="mt-3 text-sm text-gray-400">
            You need to configure both contract addresses to use all features.
          </p>
        </div>
      )}
    </div>
  );
}