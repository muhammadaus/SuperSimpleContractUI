"use client";

import React, { useEffect, useState } from 'react';
import { isAddress, parseEther, formatEther, createPublicClient, http, Address } from 'viem';
import { useTargetNetwork } from '../../../hooks/scaffold-eth/useTargetNetwork';
import { useContractStore } from "../../../utils/scaffold-eth/contract";
import { notification } from "../../../utils/scaffold-eth/notification";
import { 
  useAppKit, 
  useAppKitAccount, 
  useAppKitProvider, 
  useAppKitNetwork,
  useDisconnect,
  createAppKit
} from '@reown/appkit/react';
import { BrowserProvider, Contract } from 'ethers';
import { EthersAdapter } from '@reown/appkit-adapter-ethers';
import { mainnet, sepolia, arbitrum } from '@reown/appkit/networks';

// Initialize AppKit globally (outside of any component)
let APPKIT_INITIALIZED = false;

// Initialize AppKit synchronously
const initializeAppKit = () => {
  if (typeof window === 'undefined' || APPKIT_INITIALIZED) return true;
  
  try {
    console.log('Initializing AppKit synchronously...');
    
    const ethersAdapter = new EthersAdapter();
    createAppKit({
      adapters: [ethersAdapter],
      networks: [mainnet, sepolia, arbitrum],
      metadata: {
        name: 'PureContracts',
        description: 'Interact with your deployed contracts',
        url: window?.location?.origin || 'https://purecontracts.com',
        icons: ['https://reown.net/images/logo.png'],
      },
      projectId: process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID || 'YOUR_PROJECT_ID',
      themeMode: 'dark',
      features: {
        analytics: true,
      },
    });
    
    console.log('AppKit initialized successfully');
    APPKIT_INITIALIZED = true;
    return true;
  } catch (err) {
    console.error('Failed to initialize AppKit:', err);
    return false;
  }
};

// AppKit Initializer Component - ensures AppKit is initialized before rendering children
function AppKitInitializer({ children }: { children: React.ReactNode }) {
  const [isInitializing, setIsInitializing] = useState(!APPKIT_INITIALIZED);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    if (APPKIT_INITIALIZED) {
      console.log("AppKit already initialized, skipping initialization");
      setIsInitializing(false);
      return;
    }
    
    console.log("Starting AppKit initialization...");
    try {
      const success = initializeAppKit();
      if (success) {
        APPKIT_INITIALIZED = true;
        console.log("AppKit initialization completed successfully in component");
        setIsInitializing(false);
      } else {
        console.error("AppKit initialization failed in component");
        setError("Failed to initialize AppKit");
      }
    } catch (err) {
      console.error("Error initializing AppKit in component:", err);
      setError(err instanceof Error ? err.message : "Unknown error initializing AppKit");
    }
  }, []);
  
  if (isInitializing) {
    return (
      <div className="p-6 flex flex-col items-center justify-center min-h-[300px]">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mb-4"></div>
        <div className="text-gray-300">Initializing contract interface...</div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="p-6 flex flex-col items-center justify-center min-h-[300px]">
        <div className="text-red-400 mb-4">⚠️ Initialization Error</div>
        <div className="text-gray-300 mb-4">{error}</div>
        <button 
          onClick={() => window.location.reload()} 
          className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg"
        >
          Retry
        </button>
      </div>
    );
  }
  
  return <>{children}</>;
}

interface FunctionData {
  type: string;
  name: string;
  inputs: {type: string, name: string, internalType?: string}[];
  outputs?: {type: string, name: string, internalType?: string}[];
  stateMutability: string;
}

interface FunctionInputValue {
  [key: string]: string;
}

// Main component with AppKit hooks - only rendered when AppKit is initialized
function ReadWriteInterface() {
  const [contractName, setContractName] = useState<string>("");
  const [functions, setFunctions] = useState<FunctionData[]>([]);
  const [readFunctions, setReadFunctions] = useState<FunctionData[]>([]);
  const [writeFunctions, setWriteFunctions] = useState<FunctionData[]>([]);
  const [viewTab, setViewTab] = useState<'read' | 'write'>('read');
  const [functionInputs, setFunctionInputs] = useState<{[key: string]: FunctionInputValue}>({});
  const [functionResults, setFunctionResults] = useState<{[key: string]: any}>({});
  const [isLoading, setIsLoading] = useState<{[key: string]: boolean}>({});
  const [errorMessages, setErrorMessages] = useState<{[key: string]: string}>({});
  
  // It's now safe to use AppKit hooks because we only render this component after initialization
  const { targetNetwork } = useTargetNetwork();
  const { isConnected, address: userAddress } = useAppKitAccount();
  const { open: openAppKit } = useAppKit();
  const { walletProvider } = useAppKitProvider<any>('eip155');
  const { chainId: currentChainId, switchNetwork } = useAppKitNetwork();
  const { disconnect } = useDisconnect();
  
  // Get contract data from the store
  const contracts = useContractStore(state => state.contracts);
  const contractData = contracts?.[targetNetwork.id]?.YourContract;
  
  // Check for pending transactions when wallet connects
  useEffect(() => {
    const checkPendingTransactions = async () => {
      if (isConnected && userAddress && typeof window !== 'undefined' && walletProvider) {
        // Check if there's a timestamp to see if the connection is fresh
        const connectionTimestamp = window.sessionStorage.getItem('walletConnectionTimestamp');
        const now = Date.now();
        const isConnectionFresh = connectionTimestamp && (now - parseInt(connectionTimestamp)) < 60000; // 1 minute
        
        // Only process pending transactions if the connection is fresh
        if (isConnectionFresh) {
          // Get connection data from session storage
          const pendingFunctionName = window.sessionStorage.getItem('pendingFunctionName');
          const pendingInputValuesString = window.sessionStorage.getItem('pendingInputValues');
          
          // Clear the wallet connect progress flag
          window.sessionStorage.removeItem('walletConnectionInProgress');
          window.sessionStorage.removeItem('walletConnectionTimestamp');
          
          // Handle pending function call when wallet was connected
          if (pendingFunctionName && pendingInputValuesString) {
            try {
              const pendingInputValues = JSON.parse(pendingInputValuesString);
              
              // Only now that the wallet is connected, create the pendingFunctionTx
              window.sessionStorage.setItem('pendingFunctionTx', JSON.stringify({
                functionInputs: {
                  [pendingInputValues.functionName]: pendingInputValues.inputs
                }
              }));
              console.log("Stored pending function transaction AFTER wallet connection");
              
              // Clear the input values now that we've processed them
              window.sessionStorage.removeItem('pendingInputValues');
              
              // Apply the stored transaction inputs
              setFunctionInputs(prevInputs => ({
                ...prevInputs,
                [pendingInputValues.functionName]: pendingInputValues.inputs
              }));
              
              // Clear the stored function name
              window.sessionStorage.removeItem('pendingFunctionName');
              
              // Make sure we're in the write tab if it's a write function
              const func = [...readFunctions, ...writeFunctions].find(f => f.name === pendingFunctionName);
              if (func) {
                const isReadFunction = func.stateMutability === 'view' || func.stateMutability === 'pure';
                if (!isReadFunction) {
                  setViewTab('write');
                }
              }
              
              notification.success(`Wallet connected! Ready to execute ${pendingFunctionName}. Please submit the transaction.`);
            } catch (error) {
              console.error("Error processing pending transaction data:", error);
              window.sessionStorage.removeItem('pendingFunctionName');
              window.sessionStorage.removeItem('pendingInputValues');
            }
          }
        } else {
          // If connection is not fresh, clear any pending transaction data
          window.sessionStorage.removeItem('pendingFunctionName');
          window.sessionStorage.removeItem('pendingInputValues');
          window.sessionStorage.removeItem('pendingFunctionTx');
        }
        
        // Check if we have a previously stored transaction (from old approach)
        const pendingFunctionTx = window.sessionStorage.getItem('pendingFunctionTx');
        if (pendingFunctionTx) {
          try {
            const txData = JSON.parse(pendingFunctionTx);
            
            // Apply the stored transaction data
            if (txData.functionInputs) {
              setFunctionInputs(prevInputs => ({
                ...prevInputs,
                ...txData.functionInputs
              }));
            }
            
            // Clear the stored transaction
            window.sessionStorage.removeItem('pendingFunctionTx');
            
          } catch (error) {
            console.error("Error parsing pending transaction:", error);
            window.sessionStorage.removeItem('pendingFunctionTx');
          }
        }
      }
    };
    
    checkPendingTransactions();
  }, [isConnected, userAddress, readFunctions, writeFunctions, walletProvider]);
  
  // Clear connection flags when connection state changes
  useEffect(() => {
    // Clear all connection-related flags whenever connection state changes
    if (typeof window !== 'undefined') {
      if (isConnected) {
        // User just connected - clear all connection flags
        window.sessionStorage.removeItem('walletConnectionInProgress');
        window.sessionStorage.removeItem('walletConnectionTimestamp');
      } else {
        // User disconnected - clear pending transaction data too
        window.sessionStorage.removeItem('walletConnectionInProgress');
        window.sessionStorage.removeItem('walletConnectionTimestamp');
        window.sessionStorage.removeItem('pendingFunctionName');
        window.sessionStorage.removeItem('pendingInputValues');
        window.sessionStorage.removeItem('pendingFunctionTx');
      }
    }
  }, [isConnected]);

  // Enhanced contract interface initialization with wallet status check
  useEffect(() => {
    const initContractInterface = async () => {
      if (!contractData?.abi) {
        console.warn("No contract ABI available, skipping initialization");
        return;
      }
      
      console.log("Initializing contract interface...");
      
      try {
        // Check wallet connection status first
        console.log("Current wallet status:", {
          isConnected,
          userAddress: userAddress || "none",
          hasProvider: !!walletProvider
        });
        
        // Create a public client for read-only operations
        console.log(`Creating public client for chain ID ${targetNetwork.id}`);
        const client = createPublicClient({
          chain: targetNetwork,
          transport: http(),
        });
        
        // Try to get contract name
        try {
          console.log(`Attempting to read 'name' from contract at ${contractData.address}...`);
          const name = await client.readContract({
            address: contractData.address as Address,
            abi: contractData.abi,
            functionName: 'name',
            args: []
          });
          
          if (name) {
            const nameStr = typeof name === 'string' ? name : String(name);
            console.log(`Contract name loaded: ${nameStr}`);
            setContractName(nameStr);
          }
        } catch (error) {
          console.log("Contract might not have a name function:", error);
          // Use a fallback name if the contract doesn't have a name function
          setContractName("Smart Contract");
        }
        
        // Parse ABI to get functions
        console.log("Parsing contract ABI...");
        const abiFunctions = contractData.abi
          .filter((item: any) => item.type === 'function')
          .map((func: any) => ({
            type: func.type,
            name: func.name,
            inputs: func.inputs || [],
            outputs: func.outputs || [],
            stateMutability: func.stateMutability
          }));
        
        console.log(`Found ${abiFunctions.length} functions in ABI`);
        setFunctions(abiFunctions);
        
        // Split into read and write functions
        const reads = abiFunctions.filter((func: FunctionData) => 
          func.stateMutability === 'view' || func.stateMutability === 'pure'
        );
        
        const writes = abiFunctions.filter((func: FunctionData) => 
          func.stateMutability !== 'view' && func.stateMutability !== 'pure'
        );
        
        console.log(`Identified ${reads.length} read functions and ${writes.length} write functions`);
        setReadFunctions(reads);
        setWriteFunctions(writes);
        
        // Initialize inputs for all functions
        const initialInputs: {[key: string]: FunctionInputValue} = {};
        
        abiFunctions.forEach((func: FunctionData) => {
          initialInputs[func.name] = {};
          func.inputs.forEach(input => {
            initialInputs[func.name][input.name] = '';
          });
        });
        
        setFunctionInputs(initialInputs);
        console.log("Contract interface initialization completed successfully");
        
        // Check if there are stored transactions from a previous session
        if (typeof window !== 'undefined') {
          const pendingTx = window.sessionStorage.getItem('pendingFunctionTx');
          if (pendingTx) {
            console.log("Found pending transaction from previous session, will recover");
          }
        }
      } catch (error) {
        console.error("Error initializing contract interface:", error);
        notification.error("Failed to initialize contract interface");
      }
    };
    
    initContractInterface();
  }, [contractData, targetNetwork, isConnected, userAddress, walletProvider]);

  const handleInputChange = (functionName: string, inputName: string, value: string) => {
    setFunctionInputs(prev => ({
      ...prev,
      [functionName]: {
        ...prev[functionName],
        [inputName]: value
      }
    }));
    
    // Clear previous errors when input changes
    setErrorMessages(prev => ({
      ...prev,
      [functionName]: ''
    }));
  };

  const getParamType = (type: string) => {
    if (type.includes('int') && !type.includes('[]')) {
      return 'number';
    }
    if (type === 'bool') {
      return 'checkbox';
    }
    return 'text';
  };

  const formatValue = (value: any, type: string): string => {
    if (value === null || value === undefined) {
      return 'null';
    }
    
    if (typeof value === 'object' && BigInt.prototype.isPrototypeOf(value)) {
      return value.toString();
    }
    
    if (Array.isArray(value)) {
      return `[${value.map(v => formatValue(v, 'unknown')).join(', ')}]`;
    }
    
    if (typeof value === 'object') {
      return JSON.stringify(value);
    }
    
    if (type.includes('int') && !type.includes('[]')) {
      return value.toString();
    }
    
    if (type === 'bool') {
      return value ? 'true' : 'false';
    }
    
    return String(value);
  };

  const parseInputValue = (value: string, type: string): any => {
    if (type.includes('int') && !type.includes('[]')) {
      if (type.startsWith('uint')) {
        try {
          return BigInt(value);
        } catch (e) {
          throw new Error(`Invalid uint value: ${value}`);
        }
      } else {
        try {
          return BigInt(value);
        } catch (e) {
          throw new Error(`Invalid int value: ${value}`);
        }
      }
    }
    
    if (type === 'bool') {
      return value.toLowerCase() === 'true';
    }
    
    if (type === 'address') {
      if (!isAddress(value)) {
        throw new Error(`Invalid address: ${value}`);
      }
      return value as Address;
    }
    
    // Special case for bytes and bytes[]
    if (type === 'bytes' || type.startsWith('bytes[')) {
      // For bytes, we just ensure it's a valid hex string
      if (!value.startsWith('0x')) {
        return `0x${value}`;
      }
      return value;
    }
    
    // Special case for fixed-size bytes like bytes32
    if (type.startsWith('bytes') && !type.includes('[')) {
      if (!value.startsWith('0x')) {
        return `0x${value}`;
      }
      return value;
    }
    
    if (type.includes('[]')) {
      // If it's a bytes array, handle differently than other arrays
      if (type.startsWith('bytes[')) {
        // For bytes[] arrays, we expect the input to be comma-separated hex strings
        try {
          if (value.startsWith('[') && value.endsWith(']')) {
            // If the user entered a JSON array, parse it
            return JSON.parse(value);
          } else if (value.includes(',')) {
            // Handle comma-separated list of hex strings
            return value.split(',').map(item => {
              const trimmed = item.trim();
              return trimmed.startsWith('0x') ? trimmed : `0x${trimmed}`;
            });
          } else {
            // Single value - treat as a single-element array
            return [value.startsWith('0x') ? value : `0x${value}`];
          }
        } catch (e) {
          throw new Error(`Invalid bytes[] format. Use comma-separated hex strings or JSON array.`);
        }
      } else {
        // For other array types, we expect JSON format
        try {
          return JSON.parse(value);
        } catch (e) {
          throw new Error(`Invalid array format: ${value}. Use JSON array format: [1,2,3]`);
        }
      }
    }
    
    return value;
  };

  const callReadFunction = async (func: FunctionData) => {
    if (!contractData?.address) return;
    
    setIsLoading({ ...isLoading, [func.name]: true });
    setErrorMessages({ ...errorMessages, [func.name]: '' });
    
    try {
      const client = createPublicClient({
        chain: targetNetwork,
        transport: http(),
      });
      
      // Prepare the arguments
      const args = func.inputs.map(input => {
        const value = functionInputs[func.name]?.[input.name] || '';
        
        if (!value && input.type !== 'bool') {
          if (input.type.includes('[]')) {
            return []; // Empty array for array types
          }
          if (input.type.includes('int')) {
            return BigInt(0);
          }
          if (input.type === 'address') {
            return '0x0000000000000000000000000000000000000000' as Address;
          }
          return '';
        }
        
        return parseInputValue(value, input.type);
      });
      
      const result = await client.readContract({
        address: contractData.address as Address,
        abi: contractData.abi,
        functionName: func.name,
        args
      });
      
      console.log(`${func.name} result:`, result);
      setFunctionResults(prev => ({ ...prev, [func.name]: result }));
      
      // Show notification for successful read
      notification.success(`Successfully read ${func.name}`);
    } catch (error) {
      console.error(`Error calling ${func.name}:`, error);
      const errorMessage = (error as Error).message || 'Unknown error';
      setErrorMessages(prev => ({ ...prev, [func.name]: errorMessage }));
      notification.error(`Error calling ${func.name}: ${errorMessage}`);
    } finally {
      setIsLoading(prev => ({ ...prev, [func.name]: false }));
    }
  };

  const callWriteFunction = async (func: FunctionData) => {
    if (!contractData?.address) {
      console.error("Cannot call write function: Contract address not available");
      return;
    }
    
    console.log(`Attempting to call write function: ${func.name}`);
    setIsLoading(prev => ({ ...prev, [func.name]: true }));
    setErrorMessages(prev => ({ ...prev, [func.name]: '' }));
    
    // Check for pending transactions or connection in progress
    if (typeof window !== 'undefined') {
      const connectionInProgress = window.sessionStorage.getItem('walletConnectionInProgress');
      const pendingFunctionTx = window.sessionStorage.getItem('pendingFunctionTx');
      const pendingFunctionName = window.sessionStorage.getItem('pendingFunctionName');
      const pendingInputValues = window.sessionStorage.getItem('pendingInputValues');
      
      console.log("Connection state check:", {
        connectionInProgress,
        pendingFunctionTx: pendingFunctionTx ? "exists" : "none",
        pendingFunctionName,
        pendingInputValues: pendingInputValues ? "exists" : "none"
      });
      
      if (connectionInProgress || pendingFunctionTx || pendingFunctionName || pendingInputValues) {
        console.warn("Pending transaction or connection in progress detected");
        notification.info("There's a pending transaction or connection in progress. Please wait or reset connection state.");
        setIsLoading(prev => ({ ...prev, [func.name]: false }));
        return;
      }
    }
    
    // Check if wallet is connected, if not prompt to connect
    if (!isConnected || !userAddress) {
      console.log("Wallet not connected. Prompting connection...");
      notification.info("Please connect your wallet first");
      
      try {
        // Set a flag to indicate connection is in progress
        if (typeof window !== 'undefined') {
          const timestamp = Date.now().toString();
          window.sessionStorage.setItem('walletConnectionInProgress', 'true');
          window.sessionStorage.setItem('walletConnectionTimestamp', timestamp);
          window.sessionStorage.setItem('pendingFunctionName', func.name);
          
          console.log("Storing connection data:", { 
            timestamp,
            functionName: func.name,
            hasInputs: !!functionInputs[func.name]
          });
          
          // Store input values ONLY to be used when wallet actually connects
          window.sessionStorage.setItem('pendingInputValues', JSON.stringify({
            functionName: func.name,
            inputs: functionInputs[func.name]
          }));
        }
        
        // Open the wallet connection UI
        console.log("Opening AppKit wallet connection UI");
        openAppKit();
        
        // Clear connection flag after a timeout to prevent blocking future attempts
        setTimeout(() => {
          if (typeof window !== 'undefined') {
            console.log("Connection timeout - clearing connection progress flags");
            window.sessionStorage.removeItem('walletConnectionInProgress');
            window.sessionStorage.removeItem('walletConnectionTimestamp');
          }
        }, 30000); // 30 seconds timeout for connection attempt
        
      } catch (error) {
        console.error("Error opening wallet connection UI:", error);
        notification.error("Could not open wallet connection");
        // Clear all flags on error
        if (typeof window !== 'undefined') {
          window.sessionStorage.removeItem('walletConnectionInProgress');
          window.sessionStorage.removeItem('walletConnectionTimestamp');
          window.sessionStorage.removeItem('pendingFunctionName');
          window.sessionStorage.removeItem('pendingInputValues');
        }
      }
      
      // Turn off loading state while wallet connection happens
      setIsLoading(prev => ({ ...prev, [func.name]: false }));
      return;
    }
    
    // Enhance wallet provider check
    if (!walletProvider) {
      console.error("Wallet is connected but provider is not available");
      notification.error("Wallet is connected but provider is not available. Please try again or reset connection state.");
      setIsLoading(prev => ({ ...prev, [func.name]: false }));
      return;
    }
    
    console.log(`Wallet connected and provider available. Proceeding with ${func.name} execution...`);
    
    try {
      // Prepare the arguments
      let args: any[] = [];
      try {
        args = func.inputs.map(input => {
          const value = functionInputs[func.name]?.[input.name] || '';
          
          if (!value && input.type !== 'bool') {
            if (input.type.includes('[]')) {
              return []; // Empty array for array types
            }
            if (input.type.includes('int')) {
              return BigInt(0);
            }
            if (input.type === 'address') {
              return '0x0000000000000000000000000000000000000000' as Address;
            }
            return '';
          }
          
          return parseInputValue(value, input.type);
        });
      } catch (error) {
        console.error("Error parsing function inputs:", error);
        setErrorMessages(prev => ({ 
          ...prev, 
          [func.name]: `Invalid input: ${(error as Error).message}` 
        }));
        setIsLoading(prev => ({ ...prev, [func.name]: false }));
        return;
      }
      
      // If function is payable, determine the ETH value to send
      let ethValue = BigInt(0);
      
      if (func.stateMutability === 'payable') {
        const etherInput = functionInputs[func.name]?.['_value'] || '0';
        try {
          ethValue = parseEther(etherInput);
        } catch (error) {
          console.error("Error parsing ether value:", error);
          ethValue = BigInt(0);
        }
      }
      
      // Check if user is on the correct network
      if (currentChainId !== targetNetwork.id) {
        console.log(`User on chain ${currentChainId}, but target is ${targetNetwork.id}`);
        notification.info(`You need to switch to ${targetNetwork.name} to interact with this contract`);
        
        try {
          // Check if wallet provider is available before trying to switch
          if (!walletProvider || !walletProvider.request) {
            throw new Error("Wallet provider not available for network switching");
          }
          
          // Set loading state during network switch
          setIsLoading(prev => ({ ...prev, [func.name]: true }));
          
          try {
            // First try to switch to the chain
            await walletProvider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: `0x${targetNetwork.id.toString(16)}` }],
            });
            
            // Check if switch was successful
            if (currentChainId !== targetNetwork.id) {
              // Wait briefly for chainId to update
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // If still not on the right network, throw an error
              if (currentChainId !== targetNetwork.id) {
                throw new Error("Network switch was requested but did not complete");
              }
            }
            
            notification.success(`Switched to ${targetNetwork.name}!`);
          } catch (switchError: any) {
            // If the chain hasn't been added to the wallet yet, try to add it
            if (switchError.code === 4902 || 
                switchError.message?.includes('wallet_addEthereumChain') ||
                switchError.message?.includes('Unrecognized chain ID')) {
              // Note: Add chain implementation would go here
              // This is simplified for now
              notification.error(`Could not switch to ${targetNetwork.name}. Please add the network to your wallet.`);
              setIsLoading(prev => ({ ...prev, [func.name]: false }));
              return;
            } else {
              console.error("Error switching chain:", switchError);
              notification.error(`Could not switch to ${targetNetwork.name}`);
              setIsLoading(prev => ({ ...prev, [func.name]: false }));
              return;
            }
          }
        } catch (switchError) {
          console.error("Failed to switch network:", switchError);
          notification.error(`Failed to switch network: ${(switchError as Error).message}`);
          setIsLoading(prev => ({ ...prev, [func.name]: false }));
          return;
        }
      }

      // Contract interaction logic
      try {
        console.log("Creating ethers provider from wallet provider...");
        const provider = new BrowserProvider(walletProvider);
        
        console.log("Getting signer from provider...");
        const signer = await provider.getSigner();
        
        console.log(`Signer address: ${await signer.getAddress()}`);
        
        console.log(`Creating contract instance at ${contractData.address}...`);
        const contract = new Contract(
          contractData.address as string,
          contractData.abi,
          signer
        );
        
        // Prepare transaction options
        const options = func.stateMutability === 'payable' 
          ? { value: ethValue } 
          : {};
        
        console.log(`Calling ${func.name} with args:`, args.map(arg => 
          typeof arg === 'bigint' ? arg.toString() : arg
        ));
        
        // Call the contract function with args
        notification.info(`Please confirm the transaction in your wallet...`);
        const tx = await contract[func.name](...args, options);
        
        console.log(`Transaction sent: ${tx.hash}`);
        notification.success(`Transaction sent: ${tx.hash}`);
        
        // Wait for transaction confirmation
        try {
          console.log(`Waiting for transaction ${tx.hash} to be confirmed...`);
          const receipt = await tx.wait(1);
          console.log(`Transaction confirmed in block ${receipt.blockNumber}`);
          notification.success(`Transaction confirmed in block ${receipt.blockNumber}!`);
        } catch (confirmError) {
          console.warn("Could not confirm transaction:", confirmError);
          notification.info(`Transaction sent (${tx.hash}), but confirmation status is unknown`);
        }
        
        // Reset input values after successful transaction
        const updatedInputs = { ...functionInputs };
        func.inputs.forEach(input => {
          updatedInputs[func.name][input.name] = '';
        });
        if (func.stateMutability === 'payable') {
          updatedInputs[func.name]['_value'] = '';
        }
        setFunctionInputs(updatedInputs);
      } catch (error) {
        console.error(`Error executing ${func.name}:`, error);
        
        // User rejection handling
        if ((error as any).code === 4001 || 
            String(error).includes('user rejected') || 
            String(error).includes('User rejected')) {
          notification.error("Transaction was rejected by user");
        } else {
          // Network related errors
          if (String(error).includes('network') || String(error).includes('chain')) {
            notification.error(`Network error: ${(error as Error).message}`);
          } else {
            notification.error(`Error: ${(error as Error).message}`);
          }
        }
      } finally {
        setIsLoading(prev => ({ ...prev, [func.name]: false }));
        
        // Clear any connection flags
        if (typeof window !== 'undefined') {
          window.sessionStorage.removeItem('walletConnectionInProgress');
          window.sessionStorage.removeItem('walletConnectionTimestamp');
          window.sessionStorage.removeItem('pendingFunctionName');
        }
      }
    } catch (error) {
      console.error(`Error processing ${func.name}:`, error);
      const errorMessage = (error as Error).message || 'Unknown error';
      setErrorMessages(prev => ({ ...prev, [func.name]: errorMessage }));
      notification.error(`Error: ${errorMessage}`);
    }
  };

  const renderFunctionCard = (func: FunctionData, isRead: boolean) => {
    return (
      <div 
        key={func.name} 
        className="p-4 mb-4 rounded-xl bg-gray-800/50 backdrop-blur-sm border border-gray-700 shadow-lg"
      >
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-lg font-semibold text-blue-400">
            {func.name}
          </h3>
          <span className={`text-xs px-2 py-1 rounded-full
            ${func.stateMutability === 'view' ? 'bg-green-900/50 text-green-300' : 
              func.stateMutability === 'pure' ? 'bg-blue-900/50 text-blue-300' : 
              func.stateMutability === 'payable' ? 'bg-red-900/50 text-red-300' : 
              'bg-yellow-900/50 text-yellow-300'}`}
          >
            {func.stateMutability}
          </span>
        </div>
        
        {/* Function inputs */}
        {func.inputs.length > 0 && (
          <div className="mb-3">
            <h4 className="text-sm font-medium text-gray-300 mb-2">Inputs:</h4>
            {func.inputs.map((input, idx) => (
              <div key={idx} className="mb-2">
                <label className="block text-xs text-gray-400 mb-1">
                  {input.name || `param${idx}`} ({input.type})
                  {input.type === 'bytes' && 
                    <span className="ml-1 text-blue-400">(hex string with 0x prefix)</span>
                  }
                  {input.type.startsWith('bytes[') && 
                    <span className="ml-1 text-blue-400">(comma-separated hex strings or JSON array)</span>
                  }
                </label>
                <input
                  type={getParamType(input.type)}
                  value={functionInputs[func.name]?.[input.name] || ''}
                  onChange={(e) => handleInputChange(func.name, input.name, e.target.value)}
                  placeholder={input.type.startsWith('bytes') ? '0x0123...' : `${input.type}`}
                  className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-600 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm"
                />
                {input.type.startsWith('bytes[') && (
                  <div className="mt-1 text-xs text-gray-400">
                    Examples: 0x1234,0x5678 or ["0x1234","0x5678"]
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
        
        {/* Add value input for payable functions */}
        {func.stateMutability === 'payable' && (
          <div className="mb-3">
            <label className="block text-xs text-gray-400 mb-1">
              ETH Value to Send
            </label>
            <input
              type="text"
              value={functionInputs[func.name]?.['_value'] || ''}
              onChange={(e) => handleInputChange(func.name, '_value', e.target.value)}
              placeholder="0.0"
              className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-600 text-gray-100 placeholder-gray-500 focus:outline-none focus:ring-1 focus:ring-blue-500 text-sm"
            />
          </div>
        )}
        
        {/* Function outputs for read functions */}
        {isRead && func.outputs && func.outputs.length > 0 && (
          <div className="mb-3">
            <h4 className="text-sm font-medium text-gray-300 mb-2">Outputs:</h4>
            {functionResults[func.name] !== undefined ? (
              <div className="p-2 rounded-lg bg-gray-700/50 border border-gray-600 text-gray-100 text-sm font-mono">
                {Array.isArray(functionResults[func.name]) ? (
                  <div className="space-y-1">
                    {functionResults[func.name].map((val: any, idx: number) => (
                      <div key={idx} className="flex">
                        <span className="text-gray-400 mr-2">[{idx}]:</span>
                        <span>{formatValue(val, func.outputs && idx < func.outputs.length ? func.outputs[idx]?.type || 'unknown' : 'unknown')}</span>
                      </div>
                    ))}
                  </div>
                ) : (
                  formatValue(functionResults[func.name], func.outputs[0]?.type || 'unknown')
                )}
              </div>
            ) : (
              <div className="p-2 rounded-lg bg-gray-700/50 border border-gray-600 text-gray-500 text-sm italic">
                No data
              </div>
            )}
          </div>
        )}
        
        {/* Error message */}
        {errorMessages[func.name] && (
          <div className="mb-3 p-2 rounded-lg bg-red-900/30 border border-red-700 text-red-200 text-sm">
            {errorMessages[func.name]}
          </div>
        )}
        
        {/* Call button */}
        <button
          onClick={() => isRead ? callReadFunction(func) : callWriteFunction(func)}
          disabled={isLoading[func.name]}
          className={`w-full py-2 px-4 rounded-lg shadow-md transition-all duration-200 relative
            ${isLoading[func.name]
              ? 'bg-gray-700 cursor-not-allowed text-gray-400'
              : isRead
                ? 'bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white'
                : 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white'
            } font-medium text-sm`}
        >
          <span className={`${isLoading[func.name] ? 'opacity-0' : 'opacity-100'}`}>
            {isRead ? 'Read' : 'Write'}
          </span>
          
          {isLoading[func.name] && (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="flex gap-1">
                <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '0ms' }}></div>
                <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '150ms' }}></div>
                <div className="w-2 h-2 rounded-full bg-white animate-bounce" style={{ animationDelay: '300ms' }}></div>
              </div>
            </div>
          )}
        </button>
      </div>
    );
  };

  // Function to clear all connection flags and state
  const resetConnectionState = () => {
    console.log("Resetting all connection state...");
    
    if (typeof window !== 'undefined') {
      // Clear all session storage items related to transactions
      const keysToRemove = [
        'walletConnectionInProgress',
        'walletConnectionTimestamp',
        'pendingFunctionName',
        'pendingInputValues',
        'pendingFunctionTx'
      ];
      
      keysToRemove.forEach(key => {
        const value = window.sessionStorage.getItem(key);
        if (value) {
          console.log(`Removing session storage item: ${key} (value existed)`);
        }
        window.sessionStorage.removeItem(key);
      });
      
      // Reset all input values to empty strings
      try {
        const cleanInputs = { ...functionInputs };
        Object.keys(cleanInputs).forEach(funcName => {
          Object.keys(cleanInputs[funcName]).forEach(inputName => {
            cleanInputs[funcName][inputName] = '';
          });
        });
        setFunctionInputs(cleanInputs);
        console.log("Reset all function inputs");
      } catch (error) {
        console.error("Error resetting function inputs:", error);
      }
      
      // Reset all loading states
      try {
        const resetLoading: {[key: string]: boolean} = {};
        Object.keys(isLoading).forEach(key => {
          resetLoading[key] = false;
        });
        setIsLoading(resetLoading);
        console.log("Reset all loading states");
      } catch (error) {
        console.error("Error resetting loading states:", error);
      }
      
      // Reset all error messages
      try {
        const resetErrors: {[key: string]: string} = {};
        Object.keys(errorMessages).forEach(key => {
          resetErrors[key] = '';
        });
        setErrorMessages(resetErrors);
        console.log("Reset all error messages");
      } catch (error) {
        console.error("Error resetting error messages:", error);
      }
      
      // Also disconnect if connected
      if (isConnected) {
        console.log("Disconnecting wallet as part of reset...");
        try {
          disconnect();
        } catch (error) {
          console.error("Error disconnecting wallet:", error);
        }
      }
      
      notification.success("Connection state reset. You can try connecting again.");
    }
  };

  // Add logging to the wallet connection hooks
  useEffect(() => {
    console.log("Wallet connection state changed:", { 
      isConnected, 
      userAddress: userAddress || "none",
      walletProvider: walletProvider ? "available" : "unavailable",
      currentChainId
    });
  }, [isConnected, userAddress, walletProvider, currentChainId]);

  return (
    <div className="p-6">
      <div className="text-center mb-6">
        <h2 className="text-2xl font-bold bg-gradient-to-r from-blue-500 to-purple-500 text-transparent bg-clip-text">
          {contractName}
        </h2>
        <p className="text-md text-gray-300 mt-2">
          Interact with your deployed smart contract
        </p>
        {!userAddress && (
          <div className="mt-4 flex flex-col items-center space-y-2">
            <button
              onClick={() => openAppKit()}
              className="py-2 px-4 bg-blue-500 hover:bg-blue-600 rounded-lg transition-colors text-white text-sm font-medium"
            >
              Connect Wallet
            </button>
            <button
              onClick={resetConnectionState}
              className="py-1 px-3 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors text-gray-300 text-xs"
            >
              Reset Connection State
            </button>
          </div>
        )}
        {userAddress && (
          <div className="mt-2 text-sm text-gray-400">
            Connected: {userAddress.slice(0, 6)}...{userAddress.slice(-4)}
            <div className="flex justify-center mt-2 space-x-2">
              <button
                onClick={() => disconnect()}
                className="px-3 py-1 bg-red-700/50 hover:bg-red-700 rounded-lg transition-colors text-red-300 text-xs"
              >
                Disconnect
              </button>
              <button
                onClick={resetConnectionState}
                className="px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors text-gray-300 text-xs"
              >
                Reset Connection
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Read/Write Tabs */}
      <div className="flex justify-center mb-6">
        <div className="flex rounded-lg overflow-hidden border border-gray-700">
          <button
            onClick={() => setViewTab('read')}
            className={`px-6 py-2 ${
              viewTab === 'read'
                ? 'bg-blue-500 text-white'
                : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
            } transition-colors`}
          >
            Read
          </button>
          <button
            onClick={() => setViewTab('write')}
            className={`px-6 py-2 ${
              viewTab === 'write'
                ? 'bg-blue-500 text-white'
                : 'bg-gray-800 text-gray-300 hover:bg-gray-700'
            } transition-colors`}
          >
            Write
          </button>
        </div>
      </div>

      {/* Function Cards */}
      <div className="space-y-4">
        {viewTab === 'read' ? (
          readFunctions.length > 0 ? (
            readFunctions.map(func => renderFunctionCard(func, true))
          ) : (
            <div className="text-center text-gray-400 py-8">
              No read functions found in this contract
            </div>
          )
        ) : (
          writeFunctions.length > 0 ? (
            writeFunctions.map(func => renderFunctionCard(func, false))
          ) : (
            <div className="text-center text-gray-400 py-8">
              No write functions found in this contract
            </div>
          )
        )}
      </div>
    </div>
  );
}

// Export wrapper component that ensures AppKit is initialized first
export default function ReadWrite() {
  return (
    <AppKitInitializer>
      <ReadWriteInterface />
    </AppKitInitializer>
  );
}
