"use client";

import React, { useEffect, useState } from 'react';
import { Address, parseEther, parseUnits, formatUnits } from 'viem';
import * as viemChains from 'viem/chains';
import { useTargetNetwork } from '@/hooks/scaffold-eth/useTargetNetwork';
import { useContractStore } from "@/utils/scaffold-eth/contract";
import { notification } from "@/utils/scaffold-eth/notification";
import { 
  useAppKit, 
  useAppKitAccount, 
  useAppKitProvider, 
  useAppKitNetwork,
  useDisconnect,
  createAppKit
} from '@reown/appkit/react';
import { EthersAdapter } from '@reown/appkit-adapter-ethers';
import { BrowserProvider } from 'ethers';
import { useScaffoldContract } from '@/hooks/scaffold-eth';
import type { AppKitNetwork } from '@reown/appkit/networks';
import { ethers } from 'ethers';

// Universal Router ABI fragment for the execute function
const ROUTER_ABI = [
  "function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable",
  "function execute(bytes calldata commands, bytes[] calldata inputs) external payable",
  "function collectRewards(bytes looksRareClaim) external",
  "function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external",
  "function supportsInterface(bytes4 interfaceId) external pure returns (bool)",
  "function poolManager() external view returns (address)"
];

// PoolManager ABI fragment for direct interaction
const POOL_MANAGER_ABI = [
  "function swap(tuple(address currency0, address currency1, uint24 fee, int24 tickSpacing, address hooks) key, tuple(bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96) params, bytes hookData) external returns (int256)",
  "function settle() external payable returns (uint256)",
  "function take(address currency, address to, uint256 amount) external"
];

// Define the specific function signature for execute with deadline to avoid ambiguity
const EXECUTE_WITH_DEADLINE_SIG = "execute(bytes,bytes[],uint256)";

// Function selectors for direct interactions with Pool Manager
const POOL_MANAGER_SELECTORS = {
  UNLOCK: "0x75c3e44c", // unlock(bytes)
  SETTLE: "0x11da60b4", // settle()
  SWAP: "0x128acb08", // swap(tuple,tuple,bytes)
  TAKE: "0x0b0d9c09"  // take(address,address,uint256)
};

// Helper function for Base Sepolia Pool Manager direct calls
const directCallBaseSepoliaPoolManager = {
  // Use a lowercase address to avoid checksum validation issues
  address: "0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408",
  
  // Direct unlock & settle call via provider
  unlockAndSettle: async (provider: any, from: string, value: bigint, logger: Function) => {
    logger("Sending unlock+settle call to Pool Manager");
    
    try {
      // Encode the unlock callback data - this will be a call back to settle()
      const abiCoder = new ethers.AbiCoder();
      
      // 1. Create the callback data that will execute settle()
      const callbackData = POOL_MANAGER_SELECTORS.SETTLE;
      
      // 2. Encode the unlock data parameter
      const unlockData = abiCoder.encode(['bytes'], [callbackData]);
      
      // 3. Create the transaction data: unlock function selector + encoded parameter
      const txData = POOL_MANAGER_SELECTORS.UNLOCK + unlockData.slice(2);
      
      // Construct transaction parameters
      const txParams = {
        from: from,
        to: directCallBaseSepoliaPoolManager.address,
        value: `0x${value.toString(16)}`, // Convert to hex
        data: txData,
        gas: "0x186A0" // 100,000 gas
      };
      
      // Send transaction directly via provider
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [txParams]
      });
      
      logger(`Unlock+settle transaction sent with hash: ${txHash}`);
      
      // Create a response-like object
      return {
        hash: txHash,
        wait: async () => {
          // Poll for transaction receipt
          const checkReceipt = async (): Promise<any> => {
            const receipt = await provider.request({
              method: 'eth_getTransactionReceipt',
              params: [txHash]
            });
            
            if (receipt) {
              logger("Unlock+settle transaction confirmed");
              return receipt;
            }
            
            // Wait and retry
            await new Promise(resolve => setTimeout(resolve, 2000));
            return checkReceipt();
          };
          
          return checkReceipt();
        }
      };
    } catch (error) {
      logger(`Error in unlock+settle transaction: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  },

  // Direct unlock & swap call via provider
  unlockAndSwap: async (
    provider: any, 
    from: string, 
    poolKey: { 
      currency0: string, 
      currency1: string, 
      fee: number, 
      tickSpacing: number, 
      hooks: string 
    }, 
    swapParams: {
      zeroForOne: boolean, 
      amountSpecified: string, 
      sqrtPriceLimitX96: string
    },
    hookData: string,
    logger: Function
  ) => {
    logger("Sending unlock+swap call to Pool Manager");
    
    try {
      const abiCoder = new ethers.AbiCoder();
      
      // 1. Encode the swap parameters for the callback
      // Encode the PoolKey tuple
      const encodedPoolKey = abiCoder.encode(
        ['tuple(address,address,uint24,int24,address)'],
        [[
          poolKey.currency0,
          poolKey.currency1,
          poolKey.fee,
          poolKey.tickSpacing,
          poolKey.hooks
        ]]
      );
      
      // Encode the SwapParams tuple
      const encodedSwapParams = abiCoder.encode(
        ['tuple(bool,int256,uint160)'],
        [[
          swapParams.zeroForOne,
          swapParams.amountSpecified,
          swapParams.sqrtPriceLimitX96
        ]]
      );
      
      // Encode the hookData
      const encodedHookData = abiCoder.encode(['bytes'], [hookData]);
      
      // Create the swap callback data
      const swapCallbackData = POOL_MANAGER_SELECTORS.SWAP + 
                   encodedPoolKey.slice(2) + 
                   encodedSwapParams.slice(2) + 
                   encodedHookData.slice(2);
      
      // 2. Encode the unlock data parameter
      const unlockData = abiCoder.encode(['bytes'], [swapCallbackData]);
      
      // 3. Create the transaction data: unlock function selector + encoded parameter
      const txData = POOL_MANAGER_SELECTORS.UNLOCK + unlockData.slice(2);
      
      // Construct transaction parameters
      const txParams = {
        from: from,
        to: directCallBaseSepoliaPoolManager.address,
        data: txData,
        gas: "0xF4240" // 1,000,000 gas
      };
      
      // Send transaction directly via provider
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [txParams]
      });
      
      logger(`Unlock+swap transaction sent with hash: ${txHash}`);
      
      // Create a response-like object
      return {
        hash: txHash,
        wait: async () => {
          // Poll for transaction receipt
          const checkReceipt = async (): Promise<any> => {
            const receipt = await provider.request({
              method: 'eth_getTransactionReceipt',
              params: [txHash]
            });
            
            if (receipt) {
              logger("Unlock+swap transaction confirmed");
              return receipt;
            }
            
            // Wait and retry
            await new Promise(resolve => setTimeout(resolve, 2000));
            return checkReceipt();
          };
          
          return checkReceipt();
        }
      };
    } catch (error) {
      logger(`Error in unlock+swap transaction: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  },
  
  // Direct unlock & take call via provider
  unlockAndTake: async (provider: any, from: string, currency: string, to: string, amount: string, logger: Function) => {
    logger("Sending unlock+take call to Pool Manager");
    
    try {
      const abiCoder = new ethers.AbiCoder();
      
      // 1. Encode the take parameters for the callback
      const encodedTakeParams = abiCoder.encode(
        ['address', 'address', 'uint256'],
        [currency, to, amount]
      );
      
      // Create the take callback data
      const takeCallbackData = POOL_MANAGER_SELECTORS.TAKE + encodedTakeParams.slice(2);
      
      // 2. Encode the unlock data parameter
      const unlockData = abiCoder.encode(['bytes'], [takeCallbackData]);
      
      // 3. Create the transaction data: unlock function selector + encoded parameter
      const txData = POOL_MANAGER_SELECTORS.UNLOCK + unlockData.slice(2);
      
      // Construct transaction parameters
      const txParams = {
        from: from,
        to: directCallBaseSepoliaPoolManager.address,
        data: txData,
        gas: "0x7A120" // 500,000 gas
      };
      
      // Send transaction directly via provider
      const txHash = await provider.request({
        method: 'eth_sendTransaction',
        params: [txParams]
      });
      
      logger(`Unlock+take transaction sent with hash: ${txHash}`);
      
      // Create a response-like object
      return {
        hash: txHash,
        wait: async () => {
          // Poll for transaction receipt
          const checkReceipt = async (): Promise<any> => {
            const receipt = await provider.request({
              method: 'eth_getTransactionReceipt',
              params: [txHash]
            });
            
            if (receipt) {
              logger("Unlock+take transaction confirmed");
              return receipt;
            }
            
            // Wait and retry
            await new Promise(resolve => setTimeout(resolve, 2000));
            return checkReceipt();
          };
          
          return checkReceipt();
        }
      };
    } catch (error) {
      logger(`Error in unlock+take transaction: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
};

// Initialize AppKit at module level if not already initialized
if (typeof window !== 'undefined' && !(window as any).__APPKIT_INITIALIZED__) {
  try {
    console.log('Initializing AppKit in swap interface...');
    // Project metadata
    const metadata = {
      name: 'WrapTX Swap',
      description: 'Swap tokens using Universal Router',
      url: 'https://reown.net',
      icons: ['https://reown.net/images/logo.png'],
    };
    
    // WalletConnect project ID (get from environment or use placeholder)
    const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID || 'YOUR_PROJECT_ID';
    
    // Create ethers adapter
    const ethersAdapter = new EthersAdapter();
    
    // Generate AppKit networks from all available viem chains
    const viemChainsArray = Object.values(viemChains).filter(
      (chain): chain is typeof viemChains.mainnet => 
        typeof chain === 'object' && 
        chain !== null && 
        'id' in chain && 
        typeof chain.id === 'number'
    );
    
    // Convert viem chains to AppKit networks
    const appKitNetworks: AppKitNetwork[] = viemChainsArray.map(chain => ({
      id: chain.id,
      name: chain.name || `Chain ${chain.id}`,
      rpcUrls: {
        default: {
          http: chain.rpcUrls?.default?.http || [`https://rpc.ankr.com/${chain.id}`]
        }
      },
      nativeCurrency: {
        name: chain.nativeCurrency?.name || 'Ether',
        symbol: chain.nativeCurrency?.symbol || 'ETH',
        decimals: chain.nativeCurrency?.decimals || 18,
      },
      blockExplorers: chain.blockExplorers?.default 
        ? {
            default: {
              url: chain.blockExplorers.default.url,
              name: chain.blockExplorers.default.name || 'Explorer'
            }
          }
        : {
            default: {
              url: `https://etherscan.io`,
              name: 'Explorer'
            }
          }
    }));
    
    // Ensure we have at least mainnet as the first item
    const mainnetNetwork = appKitNetworks.find(n => n.id === 1);
    if (mainnetNetwork) {
      // Move mainnet to the beginning of the array
      const filteredNetworks = appKitNetworks.filter(n => n.id !== 1);
      const networks = [mainnetNetwork, ...filteredNetworks] as [AppKitNetwork, ...AppKitNetwork[]];
      
      console.log(`Initializing AppKit with ${networks.length} networks`);
      console.log('Networks included:', networks.map(n => `${n.name} (${n.id})`).slice(0, 5), '...');
      
      createAppKit({
        adapters: [ethersAdapter],
        networks,
        metadata,
        projectId,
        themeMode: 'dark',
        features: {
          analytics: true,
        },
        themeVariables: {
          // Theme customization if needed
        },
      });
    } else {
      throw new Error("Mainnet network not found in viem chains");
    }
    
    // Mark as initialized
    (window as any).__APPKIT_INITIALIZED__ = true;
    console.log('AppKit initialized in swap interface');
  } catch (error) {
    console.error('Error initializing AppKit:', error);
  }
}

// Add a new function to validate the Universal Router contract
async function validateUniversalRouter(contractAddress: string, provider: ethers.Provider): Promise<boolean> {
  try {
    console.log("Validating Universal Router contract at:", contractAddress);
    
    // 1. Check if contract exists by getting the bytecode
    const bytecode = await provider.getCode(contractAddress);
    if (bytecode === '0x') {
      console.error("No bytecode at address - this is not a contract");
      return false;
    }
    
    console.log(`Contract bytecode size: ${(bytecode.length - 2) / 2} bytes`);
    
    // 2. Check for Universal Router function signatures in bytecode
    const executeSignature = "0x3593564c"; // execute(bytes,bytes[],uint256)
    const executeWithoutDeadlineSignature = "0x47ccca02"; // execute(bytes,bytes[])
    
    // Simple check: look for function signatures in the bytecode
    const hasExecuteFunction = bytecode.includes(executeSignature.slice(2)); // Remove 0x prefix for search
    const hasExecuteWithoutDeadlineFunction = bytecode.includes(executeWithoutDeadlineSignature.slice(2));
    
    // Log results of checks
    console.log(`Has execute(bytes,bytes[],uint256): ${hasExecuteFunction}`);
    console.log(`Has execute(bytes,bytes[]): ${hasExecuteWithoutDeadlineFunction}`);
    
    // Additional check for Universal Router by looking for collectRewards function
    const collectRewardsSignature = "0x64f3225d"; // collectRewards(bytes)
    const hasCollectRewardsFunction = bytecode.includes(collectRewardsSignature.slice(2));
    console.log(`Has collectRewards(bytes): ${hasCollectRewardsFunction}`);
    
    // Consider it a valid Universal Router if it has at least one of the execute functions
    // and optionally the collectRewards function
    if (hasExecuteFunction || hasExecuteWithoutDeadlineFunction) {
      console.log("Contract appears to be a Universal Router");
      return true;
    } else {
      console.log("Contract does not match Universal Router signature");
      return false;
    }
  } catch (error) {
    console.error("Error validating Universal Router contract:", error);
    return false;
  }
}

// Define command and action types for Universal Router
const Commands = {
  V3_SWAP_EXACT_IN: 0x00,
  V3_SWAP_EXACT_OUT: 0x01,
  PERMIT2_TRANSFER_FROM: 0x02,
  PERMIT2_PERMIT_BATCH: 0x03,
  SWEEP: 0x04,
  TRANSFER: 0x05,
  PAY_PORTION: 0x06,
  V2_SWAP_EXACT_IN: 0x08,
  V2_SWAP_EXACT_OUT: 0x09,
  PERMIT2_PERMIT: 0x0a,
  WRAP_ETH: 0x0b,
  UNWRAP_WETH: 0x0c,
  PERMIT2_TRANSFER_FROM_BATCH: 0x0d,
  V3_SWAP_EXACT_IN_SINGLE_HOP: 0x0e,
  V3_SWAP_EXACT_OUT_SINGLE_HOP: 0x0f,
  V4_SWAP: 0x10
};

// V4 Router actions
const Actions = {
  SWAP_EXACT_IN: 0x00,
  SWAP_EXACT_OUT: 0x01,
  SWAP_EXACT_IN_SINGLE: 0x02,
  SWAP_EXACT_OUT_SINGLE: 0x03,
  SETTLE: 0x04,
  SETTLE_ALL: 0x05,
  TAKE: 0x06,
  TAKE_ALL: 0x07,
  PAY: 0x08
};

// Map fee tier to tick spacing
const getTickSpacingForFeeTier = (feeTier: number): number => {
  switch (feeTier) {
    case 100: return 1;
    case 500: return 10;
    case 3000: return 60;
    case 10000: return 200;
    default: return 10; // Default fallback
  }
};

// Generate commands for Universal Router V3 swap
const generateUniversalRouterV3Commands = (
  tokenIn: string,
  tokenOut: string,
  amountIn: string,
  minAmountOut: string,
  feeTier: number,
  deadline: string
) => {
  // Define native token address (this is the placeholder for native ETH in Uniswap)
  const NATIVE_TOKEN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const WETH_ADDRESS = "0x4200000000000000000000000000000000000006"; // Base Chain WETH
  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  
  // Determine if we're using native ETH (will require wrapping)
  const isTokenInNativeETH = !tokenIn || tokenIn.toLowerCase() === NATIVE_TOKEN.toLowerCase();
  const isTokenOutNativeETH = !tokenOut || tokenOut.toLowerCase() === NATIVE_TOKEN.toLowerCase();
  
  // Determine the actual token addresses to use (WETH instead of native ETH)
  const actualTokenIn = isTokenInNativeETH ? WETH_ADDRESS : tokenIn;
  const actualTokenOut = isTokenOutNativeETH ? WETH_ADDRESS : tokenOut;
  
  // Build the command array
  let commands = [];
  let inputs = [];
  
  // 1. If input is native ETH, add WRAP_ETH command
  if (isTokenInNativeETH) {
    commands.push(Commands.WRAP_ETH);
    
    // Encode the wrap amount
    const parsedAmountIn = parseEther(amountIn);
    inputs.push(ethers.AbiCoder.defaultAbiCoder().encode(['uint256'], [parsedAmountIn]));
  }
  
  // 2. Add the V3_SWAP_EXACT_IN_SINGLE_HOP command (more efficient than regular swap for single hop)
  commands.push(Commands.V3_SWAP_EXACT_IN_SINGLE_HOP);
  
  // Parse amounts
  const parsedAmountIn = parseEther(amountIn);
  // Set minAmountOut to a very small value close to zero
  const parsedMinAmountOut = BigInt(1); // Smallest possible positive amount
  
  // Encode the path for the swap (tokenIn -> tokenOut with fee)
  // The path is encoded as: tokenIn + fee + tokenOut
  const path = ethers.solidityPacked(
    ['address', 'uint24', 'address'],
    [actualTokenIn, feeTier, actualTokenOut]
  );
  
  // Encode the V3 swap parameters
  const v3SwapParams = ethers.AbiCoder.defaultAbiCoder().encode(
    ['bytes', 'address', 'uint256', 'uint256', 'uint256'],
    [
      path,                       // Path: tokenIn -> fee -> tokenOut
      ZERO_ADDRESS,               // Recipient (0 for sender)
      isTokenInNativeETH ? '0' : parsedAmountIn,  // Amount In (0 if wrapping ETH)
      parsedMinAmountOut,         // Minimum Amount Out
      0                           // Flags (0 for default)
    ]
  );
  
  inputs.push(v3SwapParams);
  
  // 3. If output is native ETH, add UNWRAP_WETH command
  if (isTokenOutNativeETH) {
    commands.push(Commands.UNWRAP_WETH);
    
    // Encode the unwrap parameters (recipient and amount)
    const unwrapParams = ethers.AbiCoder.defaultAbiCoder().encode(
      ['address', 'uint256'],
      [ZERO_ADDRESS, parsedMinAmountOut] // 0 address means send to msg.sender
    );
    
    inputs.push(unwrapParams);
  }
  
  // 4. Convert commands array to a single bytes value
  const commandsHex = '0x' + commands.map(c => c.toString(16).padStart(2, '0')).join('');
  
  // 5. Calculate deadline timestamp
  const deadlineTimestamp = Math.floor(Date.now() / 1000) + (parseInt(deadline) * 60);
  
  // 6. Create the full calldata
  const routerInterface = new ethers.Interface(ROUTER_ABI);
  const calldata = routerInterface.encodeFunctionData(
    EXECUTE_WITH_DEADLINE_SIG,
    [commandsHex, inputs, deadlineTimestamp]
  );
  
  return {
    commands: commandsHex,
    inputs: inputs,
    deadline: deadlineTimestamp,
    fullCalldata: calldata
  };
};

// Generate commands for Universal Router V4 swap
const generateUniversalRouterV4Commands = (
  tokenIn: string,
  tokenOut: string,
  amountIn: string,
  minAmountOut: string,
  feeTier: number,
  hookAddress: string,
  isTokenInNative: boolean,
  isTokenOutNative: boolean,
  deadline: string
) => {
  // Define native token address (this is the placeholder for native ETH in Uniswap)
  const NATIVE_TOKEN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  
  // For V4 pools, ETH must be represented as address(0) in the pool key
  // Convert the placeholder ETH address to zero address for internal use
  const internalTokenIn = isTokenInNative ? ZERO_ADDRESS : tokenIn;
  const internalTokenOut = isTokenOutNative ? ZERO_ADDRESS : tokenOut;
  
  // Sort tokens for pool key (currency0 must be lower than currency1)
  let currency0, currency1, isInputCurrency0;
  
  // Compare addresses numerically to determine order
  if (internalTokenIn.toLowerCase() < internalTokenOut.toLowerCase()) {
    currency0 = internalTokenIn;
    currency1 = internalTokenOut;
    isInputCurrency0 = true;
  } else {
    currency0 = internalTokenOut;
    currency1 = internalTokenIn;
    isInputCurrency0 = false;
  }
  
  // 1. Encode the command byte - Universal Router command for V4_SWAP
  const command = Commands.V4_SWAP;
  const commandsHex = `0x${command.toString(16).padStart(2, '0')}`;
  
  // 2. Parse amounts
  const parsedAmountIn = parseEther(amountIn);
  // Set minAmountOut to a very small value close to zero
  const parsedMinAmountOut = BigInt(1); // Smallest possible positive amount
  
  // 3. Create the pool key with properly sorted tokens
  const tickSpacing = getTickSpacingForFeeTier(feeTier);
  const poolKey = {
    currency0: currency0,
    currency1: currency1,
    fee: feeTier,
    tickSpacing: tickSpacing, // Dynamic tick spacing based on fee
    hooks: hookAddress || ZERO_ADDRESS
  };
  
  // 4. Encode V4Router actions in a byte string
  // IMPORTANT: For the Universal Router, we need to encode the actions differently
  // The Router expects a bytes string containing the action bytes
  const actions = ethers.solidityPacked(
    ['uint8', 'uint8', 'uint8'],
    [
      Actions.SWAP_EXACT_IN_SINGLE,
      Actions.SETTLE_ALL,
      Actions.TAKE_ALL
    ]
  );
  
  console.log("Encoded actions (hex):", actions);
  
  // Validate that the actions are properly encoded - they should be exactly 3 bytes
  // This is a critical check to ensure the Universal Router can properly decode them
  if (actions.length !== 8) { // 0x + 6 hex chars (3 bytes)
    console.warn("WARNING: Actions encoding length is not as expected!", {
      length: actions.length,
      expected: 8,
      actions
    });
  } else {
    console.log("Actions encoding is correct length:", actions.length);
  }
  
  // Sanity check the actions to make sure they match our expected values
  const expectedActionsHex = `0x${Actions.SWAP_EXACT_IN_SINGLE.toString(16).padStart(2, '0')}${Actions.SETTLE_ALL.toString(16).padStart(2, '0')}${Actions.TAKE_ALL.toString(16).padStart(2, '0')}`;
  console.log("Expected actions hex:", expectedActionsHex);
  if (actions !== expectedActionsHex) {
    console.warn("WARNING: Actions encoding doesn't match expected value!", {
      encoded: actions,
      expected: expectedActionsHex
    });
  } else {
    console.log("Actions encoding matches expected value");
  }
  
  // 5. Prepare parameters for each action
  // 5.1 SWAP_EXACT_IN_SINGLE params
  const swapParams = {
    poolKey: poolKey,
    zeroForOne: isInputCurrency0,
    amountIn: parsedAmountIn.toString(),
    amountOutMinimum: parsedMinAmountOut.toString(),
    sqrtPriceLimitX96: "0", // uint160(0)
    hookData: "0x"
  };

  // 5.1 SWAP_EXACT_IN_SINGLE params with explicit conversion for sqrtPriceLimitX96
  const swapParams = {
    poolKey: poolKey,
    zeroForOne: isInputCurrency0,
    amountIn: parsedAmountIn.toString(),
    amountOutMinimum: parsedMinAmountOut.toString(),
    // Explicitly set sqrtPriceLimitX96 to uint160(0) as required by the docs
    sqrtPriceLimitX96: "0",
    hookData: "0x"
  };
  
  // 5. Prepare parameters for each action
  // 5.1 SWAP_EXACT_IN_SINGLE params with explicit sqrtPriceLimitX96
  const swapParams = {
    poolKey: poolKey,
    zeroForOne: isInputCurrency0,
    amountIn: parsedAmountIn.toString(),
    amountOutMinimum: parsedMinAmountOut.toString(),
    // Explicitly set sqrtPriceLimitX96 to uint160(0) as required by the docs
    sqrtPriceLimitX96: "0",
    hookData: "0x"
  };
  
  // 5. Prepare parameters for each action
  // 5.1 SWAP_EXACT_IN_SINGLE params with explicit sqrtPriceLimitX96
  const swapParams = {
    poolKey: poolKey,
    zeroForOne: isInputCurrency0,
    amountIn: parsedAmountIn.toString(),
    amountOutMinimum: parsedMinAmountOut.toString(),
    // Explicitly set sqrtPriceLimitX96 to uint160(0) as required by the docs
    sqrtPriceLimitX96: "0",
    hookData: "0x"
  };
  
  // 5. Prepare parameters for each action
  // 5.1 SWAP_EXACT_IN_SINGLE params with explicit sqrtPriceLimitX96
  const swapParams = {
    poolKey: poolKey,
    zeroForOne: isInputCurrency0,
    amountIn: parsedAmountIn.toString(),
    amountOutMinimum: parsedMinAmountOut.toString(),
    // Explicitly set sqrtPriceLimitX96 to uint160(0) as required by the docs
    sqrtPriceLimitX96: "0",
    hookData: "0x"
  };
  
  // Match settlement with the docs exactly - if input is currency0, use currency0
  // But ensure we use the display version (ETH placeholder) not address(0)
  let displayCurrency0 = poolKey.currency0;
  let displayCurrency1 = poolKey.currency1;

  // Use ETH placeholder for displays if relevant
  if (displayCurrency0 === ZERO_ADDRESS) {
    displayCurrency0 = NATIVE_TOKEN;
  }
  if (displayCurrency1 === ZERO_ADDRESS) {
    displayCurrency1 = NATIVE_TOKEN;
  }

  // Follow docs exactly - settle with currency0, take from currency1
  const settleParams = [displayCurrency0, parsedAmountIn.toString()];
  const takeParams = [displayCurrency1, parsedMinAmountOut.toString()];
  
  // 6. Encode all parameters into ABI-encoded format
  const ethersAbiCoder = new ethers.AbiCoder();
  
  // Log debugging info about parameters
  console.log("V4 Swap Parameters:", {
    isTokenInNative,
    isTokenOutNative,
    isInputCurrency0,
    currency0,
    currency1,
    zeroForOne: swapParams.zeroForOne,
    settleParams,
    takeParams,
    inputAmount: parsedAmountIn.toString(),
  });
  
  // CRITICAL FIX: Encode the swap parameters according to the V4Router API
  const encodedSwapParams = ethersAbiCoder.encode(
    ['tuple(tuple(address,address,uint24,int24,address),bool,uint256,uint256,uint160,bytes)'],
    [[
      [
        poolKey.currency0,
        poolKey.currency1, 
        poolKey.fee,
        poolKey.tickSpacing,
        poolKey.hooks
      ],
      swapParams.zeroForOne,
      swapParams.amountIn,
      swapParams.amountOutMinimum,
      swapParams.sqrtPriceLimitX96,
      swapParams.hookData
    ]]
  );
  
  // Encode the settle parameters
  const encodedSettleParams = ethersAbiCoder.encode(
    ['address', 'uint256'],
    settleParams
  );
  
  // Encode the take parameters
  const encodedTakeParams = ethersAbiCoder.encode(
    ['address', 'uint256'],
    takeParams
  );
  
  // 7. Combine params into an array
  const paramsArray = [encodedSwapParams, encodedSettleParams, encodedTakeParams];
  
  // Validate params array length
  if (paramsArray.length !== 3) {
    console.warn("WARNING: Params array length is not 3!", {
      length: paramsArray.length,
      paramsArray
    });
  } else {
    console.log("Params array length is correct:", paramsArray.length);
  }
  
  // Check that params array matches the number of actions
  const actionCount = actions.length / 2 - 1; // -1 for the '0x' prefix, divide by 2 for bytes
  if (paramsArray.length !== actionCount) {
    console.warn("WARNING: Params array length doesn't match action count!", {
      paramsLength: paramsArray.length,
      actionCount,
      actions
    });
  } else {
    console.log("Params array length matches action count");
  }
  
  // 8. Create the V4Router input - This is CRITICAL for correct Universal Router execution
  // The Universal Router needs a single input for the V4_SWAP command
  // This input contains the actions and parameters for the V4Router to execute
  const v4RouterInput = ethersAbiCoder.encode(
    ['bytes', 'bytes[]'],
    [actions, paramsArray]
  );
  
  // 9. Create the final inputs array for the Universal Router execute function
  const inputsArray = [v4RouterInput];
  
  // 10. Calculate deadline timestamp
  const deadlineTimestamp = Math.floor(Date.now() / 1000) + (parseInt(deadline) * 60);
  
  // Create the full raw calldata
  const routerInterface = new ethers.Interface(ROUTER_ABI);
  const calldata = routerInterface.encodeFunctionData(
    EXECUTE_WITH_DEADLINE_SIG,
    [commandsHex, inputsArray, deadlineTimestamp]
  );
  
  // Extra logging for debugging
  console.log("==== V4 SWAP COMMAND DATA ====");
  console.log("Command:", commandsHex);
  console.log("Actions:", actions);
  console.log("Action bytes:", Buffer.from(actions.slice(2), 'hex')); // Show bytes (0x02, 0x05, 0x07)
  console.log("Pool Key:", {
    currency0: poolKey.currency0,
    currency1: poolKey.currency1,
    fee: poolKey.fee,
    tickSpacing: poolKey.tickSpacing,
    hooks: poolKey.hooks
  });
  console.log("Swap parameters:", {
    poolKey: poolKey,
    zeroForOne: swapParams.zeroForOne,
    amountIn: swapParams.amountIn,
    amountOutMinimum: swapParams.amountOutMinimum,
    sqrtPriceLimitX96: swapParams.sqrtPriceLimitX96,
    hookData: swapParams.hookData
  });
  console.log("Params Array:", paramsArray.map(p => p.substring(0, 66) + "..."));
  console.log("Full Inputs Array:", inputsArray.map(i => i.substring(0, 66) + "..."));
  console.log("============================");
  
  return {
    commands: commandsHex,
    inputs: inputsArray,
    deadline: deadlineTimestamp,
    fullCalldata: calldata
  };
};

// Execute a Universal Router swap with generated commands
const executeUniversalRouterSwap = async (
  provider: any,
  signer: ethers.Signer,
  routerAddress: string,
  commandsData: {
    commands: string,
    inputs: any[],
    deadline: number,
    fullCalldata: string
  },
  value: bigint
) => {
  try {
    // Execute the transaction directly using the signer without any estimateGas check
    const tx = await signer.sendTransaction({
      to: routerAddress.toLowerCase(), // Ensure lowercase to avoid checksum validation
      data: commandsData.fullCalldata,
      value,
      // Send with high gas limit to avoid estimation failures
      gasLimit: 3000000
    });
    
    console.log(`Transaction sent with hash: ${tx.hash}`);
    return tx;
  } catch (error) {
    console.error("Error executing swap:", error);
    throw error;
  }
};

// Add a simple SwapInterface component
export default function SwapInterface() {
  // Move these hooks inside the component
  const { address: userAddress, isConnected } = useAppKitAccount();
  const appKit = useAppKit();
  
  const [tokenIn, setTokenIn] = useState<string>('');
  const [tokenOut, setTokenOut] = useState<string>('');
  const [amountIn, setAmountIn] = useState<string>('');
  const [amountOut, setAmountOut] = useState<string>('');
  const [deadline, setDeadline] = useState<string>('30'); // Default 30 minutes
  const [commandsHex, setCommandsHex] = useState<string>('');
  const [inputsArray, setInputsArray] = useState<string[]>([]);
  const [swapMode, setSwapMode] = useState<'v3' | 'v4'>('v3'); // Default to V3
  const [directSwapMode, setDirectSwapMode] = useState<boolean>(false);
  const [isExecuting, setIsExecuting] = useState<boolean>(false);
  const [poolManagerAddress, setPoolManagerAddress] = useState<string | null>(null);
  const [isTokenInNative, setIsTokenInNative] = useState<boolean>(true);
  const [isTokenOutNative, setIsTokenOutNative] = useState<boolean>(false);
  const [hookAddress, setHookAddress] = useState<string>('0x0000000000000000000000000000000000000000');
  const [directSwapLogs, setDirectSwapLogs] = useState<string[]>([]);
  const [feeTier, setFeeTier] = useState<number>(3000); // Default 0.3%
  
  // Add new state variables for logging Universal Router operations
  const [universalRouterLogs, setUniversalRouterLogs] = useState<string[]>([]);
  const [generatedCommandsData, setGeneratedCommandsData] = useState<any>(null);
  
  // Function to log messages for Direct Swap
  const logDirectSwap = (message: string) => {
    console.log(`[Direct Swap] ${message}`);
    setDirectSwapLogs(prev => [...prev, `${new Date().toLocaleTimeString()}: ${message}`]);
  };
  
  // Function to log Universal Router messages
  const logUniversalRouter = (message: string) => {
    console.log(`[Universal Router] ${message}`);
    setUniversalRouterLogs(prev => [...prev, `${new Date().toLocaleTimeString()}: ${message}`]);
  };
  
  // Add generateCommands function
  const generateCommands = async () => {
    // Clear previous logs
    // setUniversalRouterLogs([]);
    setGeneratedCommandsData(null);
    
    try {
      // logUniversalRouter("Starting command generation");
      
      // Check wallet connection
      if (!isConnected || !userAddress) {
        try {
          appKit.open();
          return;
        } catch (error) {
          console.error("Error opening wallet:", error);
          return;
        }
      }
      
      // Default minimum amount out to 0 if not specified
      const minAmountOut = amountOut || "0";
      
      // Generate commands based on selected swap mode
      let commandsData;
      if (swapMode === 'v4') {
        commandsData = generateUniversalRouterV4Commands(
          tokenIn,
          tokenOut,
          amountIn,
          minAmountOut,
          feeTier,
          hookAddress,
          isTokenInNative,
          isTokenOutNative,
          deadline
        );
      } else {
        commandsData = generateUniversalRouterV3Commands(
          tokenIn,
          tokenOut,
          amountIn,
          minAmountOut,
          feeTier,
          deadline
        );
      }
      
      // Store generated commands
      setCommandsHex(commandsData.commands);
      setInputsArray([JSON.stringify(commandsData.inputs, null, 2)]);
      setGeneratedCommandsData(commandsData);
      
      // logUniversalRouter("Commands generated successfully");
      notification.success("Commands generated successfully");
    } catch (error) {
      console.error("Error generating commands:", error);
      notification.error("Failed to generate commands");
    }
  };

  // Add executeSwap function
  const executeSwap = async () => {
    setIsExecuting(true);
    
    try {
      // Check wallet connection
      if (!isConnected || !userAddress) {
        try {
          appKit.open();
        } catch (error) {
          console.error("Error opening wallet:", error);
        }
        setIsExecuting(false);
        return;
      }
      
      // Check if commands were generated
      if (!generatedCommandsData) {
        await generateCommands();
        
        // Check if we now have generated commands
        if (!generatedCommandsData) {
          setIsExecuting(false);
          return;
        }
      }
      
      // Get ethers provider from AppKit
      const ethProvider = await (window as any).ethereum;
      if (!ethProvider) {
        setIsExecuting(false);
        return;
      }
      
      const provider = new ethers.BrowserProvider(ethProvider);
      
      // Get ethers signer from provider
      const signer = await provider.getSigner();
      
      // Get current network
      const network = await provider.getNetwork();
      const chainId = network.chainId;
      const chainIdNumber = Number(chainId);
      
      // Default Universal Router addresses by network
      const routerAddresses = {
        1: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Ethereum Mainnet
        5: "0xF7a0ef3C19caAA48eE6B13F26455a3aC109D4f29", // Goerli
        137: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Polygon
        42161: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Arbitrum
        10: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Optimism
        84532: "0x492E6456D9528771018DeB9E87ef7750EF184104", // Base Sepolia testnet
        // Add more networks as needed
      };
      
      // Get the router address for the current network
      const routerAddress = routerAddresses[chainIdNumber as keyof typeof routerAddresses] || routerAddresses[1];
      
      // Prepare the value for the transaction (only if token in is native)
      const value = isTokenInNative ? parseEther(amountIn) : BigInt(0);
      
      // Execute the swap
      await executeUniversalRouterSwap(
        provider,
        signer,
        routerAddress,
        generatedCommandsData,
        value
      );
      
      notification.success("Swap executed successfully!");
    } catch (error) {
      console.error("Error executing swap:", error);
      notification.error("Failed to execute swap");
    } finally {
      setIsExecuting(false);
    }
  };

  // Update the executeDirectSwap function with actual transaction creation
  const executeDirectSwap = async () => {
    // Clear previous logs
    setDirectSwapLogs([]);
    setIsExecuting(true);
    
    try {
      // Start logging
      logDirectSwap("Starting direct swap via Pool Manager");
      
      // Check wallet connection
      if (!isConnected || !userAddress) {
        logDirectSwap("Error: Wallet not connected");
        notification.info("Please connect your wallet first");
        try {
          appKit.open();
        } catch (error) {
          logDirectSwap(`Error opening wallet: ${error instanceof Error ? error.message : String(error)}`);
        }
        setIsExecuting(false);
        return;
      }
      
      logDirectSwap(`Wallet connected: ${userAddress}`);
      
      // Validate inputs
      if (!tokenIn && !isTokenInNative) {
        logDirectSwap("Error: Token In address is required");
        notification.error("Token In address is required");
        setIsExecuting(false);
        return;
      }
      
      if (!tokenOut && !isTokenOutNative) {
        logDirectSwap("Error: Token Out address is required");
        notification.error("Token Out address is required");
        setIsExecuting(false);
        return;
      }
      
      if (!amountIn || parseFloat(amountIn) <= 0) {
        logDirectSwap("Error: Amount In must be greater than 0");
        notification.error("Amount In must be greater than 0");
        setIsExecuting(false);
        return;
      }
      
      // Get ethers provider from AppKit
      logDirectSwap("Getting provider from wallet...");
      // Get ethers provider directly
      const ethProvider = await (window as any).ethereum;
      if (!ethProvider) {
        logDirectSwap("Error: Could not get provider from wallet");
        notification.error("Could not get provider from wallet");
        setIsExecuting(false);
        return;
      }
      
      const provider = new ethers.BrowserProvider(ethProvider);
      
      // Get ethers signer from provider
      logDirectSwap("Getting signer from provider...");
      const signer = await provider.getSigner();

      // Get current network
      const network = await provider.getNetwork();
      const chainId = network.chainId;
      const chainIdNumber = Number(chainId);
      logDirectSwap(`Connected to network with chainId: ${chainIdNumber}`);
      
      // Default Universal Router addresses by network
      const routerAddresses = {
        1: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Ethereum Mainnet
        5: "0xF7a0ef3C19caAA48eE6B13F26455a3aC109D4f29", // Goerli
        137: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Polygon
        42161: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Arbitrum
        10: "0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD", // Optimism
        84532: "0x492E6456D9528771018DeB9E87ef7750EF184104", // Base Sepolia testnet
        // Add more networks as needed
      };
      
      // Base Sepolia special case (chainId 84532)
      if (chainIdNumber === 84532) {
        // Skip setting poolManagerAddress state and directly use a special case for Base Sepolia
        const baseSepoliaPoolManager = "0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408";
        setPoolManagerAddress(baseSepoliaPoolManager);
        logDirectSwap(`Using known Pool Manager address for Base Sepolia: ${baseSepoliaPoolManager}`);
        
        // Parse amount
        let parsedAmountIn;
        try {
          parsedAmountIn = parseEther(amountIn);
          logDirectSwap(`Parsed amount: ${parsedAmountIn.toString()} wei`);
        } catch (error) {
          logDirectSwap(`Error parsing amount: ${error instanceof Error ? error.message : String(error)}`);
          notification.error("Invalid amount format");
          setIsExecuting(false);
          return;
        }
        
        // Set minimum amount out (for safety in direct swap)
        const parsedMinAmountOut = BigInt(1); // Smallest possible positive amount
        
        // Define native token address (WETH)
        const NATIVE_TOKEN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
        
        // Define zero address for ETH in pool keys
        const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
        
        // Define token addresses for the swap
        const currency0 = isTokenInNative ? NATIVE_TOKEN : tokenIn;
        const currency1 = isTokenOutNative ? NATIVE_TOKEN : tokenOut;
        
        // Prepare logging of parameters
        logDirectSwap(`Pool Fee Tier: ${feeTier / 10000}% (${feeTier})`);
        logDirectSwap(`Token In: ${isTokenInNative ? 'Native ETH' : tokenIn}`);
        logDirectSwap(`Token Out: ${isTokenOutNative ? 'Native ETH' : tokenOut}`);
        logDirectSwap(`Amount In: ${amountIn} ${isTokenInNative ? 'ETH' : ''}`);
        logDirectSwap(`Hook Address: ${hookAddress}`);
        
        // Use the direct ethereum provider to avoid any validation issues
        try {
          // Step 1: Call unlock+settle with ETH value if using native ETH
          if (isTokenInNative) {
            logDirectSwap("Step 1: Calling unlock+settle with ETH value directly");
            const settleTx = await directCallBaseSepoliaPoolManager.unlockAndSettle(
              ethProvider,
              userAddress,
              parsedAmountIn,
              logDirectSwap
            );
            
            await settleTx.wait();
            logDirectSwap("Unlock+settle transaction confirmed");
            
            // Step 2: Call unlock+swap directly
            logDirectSwap("Step 2: Calling unlock+swap directly");
            
            // Define the pool key
            const poolKey = {
              currency0: currency0,
              currency1: currency1,
              fee: feeTier,
              tickSpacing: 10, // Default tick spacing for this fee tier
              hooks: hookAddress
            };
            
            // Define swap parameters
            const swapParams = {
              zeroForOne: true, // Assuming trading token0 for token1
              amountSpecified: parsedAmountIn.toString(),
              sqrtPriceLimitX96: "0" // No price limit
            };
            
            const swapTx = await directCallBaseSepoliaPoolManager.unlockAndSwap(
              ethProvider,
              userAddress,
              poolKey,
              swapParams,
              "0x", // Empty hook data
              logDirectSwap
            );
            
            await swapTx.wait();
            logDirectSwap("Unlock+swap transaction confirmed");
            
            // Step 3: Call unlock+take directly to withdraw the output token if needed
            if (!isTokenOutNative) {
              logDirectSwap("Step 3: Calling unlock+take directly to withdraw output token");
              const takeTx = await directCallBaseSepoliaPoolManager.unlockAndTake(
                ethProvider,
                userAddress,
                currency1,
                userAddress,
                "115792089237316195423570985008687907853269984665640564039457584007913129639935", // MaxUint256 as string
                logDirectSwap
              );
              
              await takeTx.wait();
              logDirectSwap("Unlock+take transaction confirmed");
            }
            
            notification.success("Base Sepolia swap completed successfully!");
            logDirectSwap("Direct swap completed successfully!");
          } else {
            logDirectSwap("Non-native token swaps not supported in direct mode for Base Sepolia yet");
            notification.info("Only ETH input is supported for Base Sepolia direct swaps");
          }
        } catch (error) {
          logDirectSwap(`Error with Base Sepolia Pool Manager: ${error instanceof Error ? error.message : String(error)}`);
          notification.error(`Failed to execute transaction: ${error instanceof Error ? error.message : 'Unknown error'}`);
        } finally {
          setIsExecuting(false);
        }
        return;
      }
      
      // For other networks, use the regular flow
      let poolManagerAddress = null;
      
      // Get the router address for the current network
      const routerAddress = routerAddresses[chainIdNumber as keyof typeof routerAddresses] || routerAddresses[1];
      logDirectSwap(`Using Universal Router address: ${routerAddress}`);
      
      try {
        // Connect to Universal Router contract
        const routerContract = new ethers.Contract(routerAddress, ROUTER_ABI, provider);
        
        // Call poolManager() function to get the address
        poolManagerAddress = await routerContract.poolManager();
        logDirectSwap(`Retrieved Pool Manager address: ${poolManagerAddress}`);
      } catch (error) {
        logDirectSwap(`Error getting Pool Manager address: ${error instanceof Error ? error.message : String(error)}`);
        
        // Fallback addresses for Pool Manager
        const poolManagerAddresses = {
          1: "0x8F8BB357633E92ecE8CAa46b5A9203E35e4CC5a0", // Ethereum Mainnet
          // Add more networks as needed
        };
        
        poolManagerAddress = poolManagerAddresses[chainIdNumber as keyof typeof poolManagerAddresses] || poolManagerAddresses[1]; // Fallback to mainnet
        logDirectSwap(`Using fallback Pool Manager for chainId ${chainIdNumber}: ${poolManagerAddress}`);
      }
      
      if (!poolManagerAddress) {
        logDirectSwap("Error: Could not determine Pool Manager address");
        notification.error("Could not determine Pool Manager address");
        setIsExecuting(false);
        return;
      }
      
      setPoolManagerAddress(poolManagerAddress);
      logDirectSwap(`Using Pool Manager at address: ${poolManagerAddress}`);
      
      try {
        // Create Pool Manager contract instance
        const checksummedAddress = ethers.getAddress(poolManagerAddress);
        logDirectSwap(`Using checksummed Pool Manager address: ${checksummedAddress}`);
        
        const poolManagerContract = new ethers.Contract(checksummedAddress, POOL_MANAGER_ABI, signer);
        
        // Prepare parameters
        logDirectSwap(`Pool Fee Tier: ${feeTier / 10000}% (${feeTier})`);
        logDirectSwap(`Token In: ${isTokenInNative ? 'Native ETH' : tokenIn}`);
        logDirectSwap(`Token Out: ${isTokenOutNative ? 'Native ETH' : tokenOut}`);
        logDirectSwap(`Amount In: ${amountIn} ${isTokenInNative ? 'ETH' : ''}`);
        logDirectSwap(`Hook Address: ${hookAddress}`);
        
        // Define native token address (WETH)
        const NATIVE_TOKEN = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
        
        // Define zero address for ETH in pool keys
        const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
        
        // Define token addresses for the swap
        const currency0 = isTokenInNative ? NATIVE_TOKEN : tokenIn;
        const currency1 = isTokenOutNative ? NATIVE_TOKEN : tokenOut;
        
        // Parse amount
        let parsedAmountIn;
        try {
          parsedAmountIn = parseEther(amountIn);
          logDirectSwap(`Parsed amount: ${parsedAmountIn.toString()} wei`);
        } catch (error) {
          logDirectSwap(`Error parsing amount: ${error instanceof Error ? error.message : String(error)}`);
          notification.error("Invalid amount format");
          setIsExecuting(false);
          return;
        }
        
        // Set minimum amount out (for safety in direct swap)
        const parsedMinAmountOut = BigInt(1); // Smallest possible positive amount
        
        // Execute the swap in multiple steps
        logDirectSwap("Executing direct swap...");
        
        try {
          // Step 1: Call unlock+settle with ETH value if using native ETH
          if (isTokenInNative) {
            logDirectSwap("Step 1: Calling unlock+settle with ETH value");
            const settleTx = await poolManagerContract.settle({
              value: parsedAmountIn
            });
            logDirectSwap(`Settle transaction sent with hash: ${settleTx.hash}`);
            await settleTx.wait();
            logDirectSwap("Settle transaction confirmed");
          }
          
          // Step 2: Call unlock+swap
          logDirectSwap("Step 2: Calling unlock+swap");
          
          // Define the pool key
          const poolKey = {
            currency0: currency0,
            currency1: currency1,
            fee: feeTier,
            tickSpacing: 10, // Default tick spacing for this fee tier
            hooks: hookAddress
          };
          
          // Define swap parameters
          const swapParams = {
            zeroForOne: true, // Assuming trading token0 for token1
            amountIn: parsedAmountIn.toString(),
            sqrtPriceLimitX96: "0", // This should be uint160(0)
            hookData: "0x"
          };
          
          // Fix the sqrtPriceLimitX96 to be uint160(0)
          swapParams.sqrtPriceLimitX96 = "0"; // Ethers will format this correctly

          // Execute the swap
          const swapTx = await poolManagerContract.swap(
            poolKey,
            swapParams,
            "0x" // Empty hook data
          );
          
          logDirectSwap(`Swap transaction sent with hash: ${swapTx.hash}`);
          await swapTx.wait();
          logDirectSwap("Swap transaction confirmed");
          
          // Step 3: Call unlock+take to withdraw the output token
          if (!isTokenOutNative) {
            logDirectSwap("Step 3: Calling unlock+take to withdraw output token");
            const takeTx = await poolManagerContract.take(
              currency1,
              userAddress,
              BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") // MaxUint256
            );
            
            logDirectSwap(`Take transaction sent with hash: ${takeTx.hash}`);
            await takeTx.wait();
            logDirectSwap("Take transaction confirmed");
          }
          
          notification.success("Direct swap completed successfully!");
          logDirectSwap("Direct swap completed successfully!");
        } catch (error: any) {
          logDirectSwap(`Error executing swap: ${error instanceof Error ? error.message : String(error)}`);
          
          // Try to extract revert reason if available
          if (error.data) {
            logDirectSwap(`Error data: ${error.data}`);
          }
          
          notification.error(`Failed to execute swap: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      } catch (error) {
        logDirectSwap(`Error with Pool Manager contract: ${error instanceof Error ? error.message : String(error)}`);
        notification.error(`Failed to execute swap: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    } catch (error) {
      logDirectSwap(`Unexpected error: ${error instanceof Error ? error.message : String(error)}`);
      notification.error(`Failed to execute swap: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsExecuting(false);
    }
  };

  // Simple render function for testing
  const renderInterface = () => {
    return (
      <div className="bg-base-100 shadow-xl rounded-3xl p-6 md:p-8 w-full max-w-2xl mx-auto">
        <h2 className="text-2xl font-bold text-center mb-6 bg-gradient-to-r from-blue-500 to-purple-500 text-transparent bg-clip-text">Uniswap Universal Router Interface</h2>
        
        {/* Protocol selector */}
        <div className="mb-6">
          <h3 className="text-md font-medium text-gray-300 mb-2">Swap Protocol</h3>
          <div className="flex space-x-4">
            <button
              className={`py-2 px-4 rounded-lg shadow-md transition-all duration-200 flex-1 ${
                !directSwapMode 
                  ? 'bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white' 
                  : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              }`}
              onClick={() => setDirectSwapMode(false)}
            >
              Universal Router
            </button>
            <button
              className={`py-2 px-4 rounded-lg shadow-md transition-all duration-200 flex-1 ${
                directSwapMode 
                  ? 'bg-gradient-to-r from-orange-600 to-red-600 hover:from-orange-700 hover:to-red-700 text-white' 
                  : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              }`}
              onClick={() => setDirectSwapMode(true)}
            >
              Direct Pool Manager
            </button>
          </div>
          <p className="mt-2 text-xs text-gray-400">
            {directSwapMode 
              ? 'Direct swap through Pool Manager - experimental, for advanced users only' 
              : 'Using Universal Router - the recommended way to swap'}
          </p>
        </div>
        
        {/* Swap mode selector - only show if using Universal Router */}
        {!directSwapMode && (
          <div className="mb-6">
            <h3 className="text-md font-medium text-gray-300 mb-2">Swap Protocol Version</h3>
            <div className="flex space-x-4">
              <button
                className={`py-2 px-4 rounded-lg shadow-md transition-all duration-200 flex-1 ${
                  swapMode === 'v3' 
                    ? 'bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white' 
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
                onClick={() => setSwapMode('v3')}
              >
                Uniswap V3
              </button>
              <button
                className={`py-2 px-4 rounded-lg shadow-md transition-all duration-200 flex-1 ${
                  swapMode === 'v4' 
                    ? 'bg-gradient-to-r from-green-600 to-teal-600 hover:from-green-700 hover:to-teal-700 text-white' 
                    : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                }`}
                onClick={() => setSwapMode('v4')}
              >
                Uniswap V4
              </button>
            </div>
            <p className="mt-2 text-xs text-gray-400">
              {swapMode === 'v3' 
                ? 'Using Uniswap V3 pools - available on most networks' 
                : 'Using Uniswap V4 pools - might not be available on all networks'}
            </p>
          </div>
        )}
        
        <div className="form-control mb-4">
          <label className="label">
            <span className="label-text text-sm font-medium text-gray-300">Token In</span>
          </label>
          <div className="flex space-x-2">
            <input
              type="text"
              placeholder="Token In Address"
              className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100"
              value={tokenIn}
              onChange={(e) => setTokenIn(e.target.value)}
              disabled={isTokenInNative}
            />
            <button
              className={`btn rounded-lg shadow-md transition-all duration-200 ${isTokenInNative ? 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
              onClick={() => setIsTokenInNative(!isTokenInNative)}
            >
              ETH
            </button>
          </div>
          {directSwapMode && !isTokenInNative && (
            <p className="mt-1 text-xs text-yellow-400">
              Warning: Direct Pool Manager swaps with ERC20 tokens require additional approval steps.
            </p>
          )}
        </div>
        
        <div className="form-control mb-4">
          <label className="label">
            <span className="label-text text-sm font-medium text-gray-300">Token Out</span>
          </label>
          <div className="flex space-x-2">
            <input
              type="text"
              placeholder="Token Out Address"
              className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100"
              value={tokenOut}
              onChange={(e) => setTokenOut(e.target.value)}
              disabled={isTokenOutNative}
            />
            <button
              className={`btn rounded-lg shadow-md transition-all duration-200 ${isTokenOutNative ? 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
              onClick={() => setIsTokenOutNative(!isTokenOutNative)}
            >
              ETH
            </button>
          </div>
        </div>
        
        <div className="form-control mb-4">
          <label className="label">
            <span className="label-text text-sm font-medium text-gray-300">Amount In</span>
          </label>
          <input
            type="text"
            placeholder="Amount of tokens to swap"
            className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100"
            value={amountIn}
            onChange={(e) => setAmountIn(e.target.value)}
          />
        </div>
        
        {/* Fee Tier Selector */}
        <div className="form-control mb-4">
          <label className="label">
            <span className="label-text text-sm font-medium text-gray-300">Fee Tier</span>
          </label>
          <select 
            className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100"
            value={feeTier}
            onChange={(e) => setFeeTier(Number(e.target.value))}
          >
            <option value="500">0.05%</option>
            <option value="3000">0.3%</option>
            <option value="10000">1%</option>
          </select>
        </div>
        
        {/* Hook Address Input - only show for Direct Pool Manager */}
        {directSwapMode && (
          <div className="form-control mb-4">
            <label className="label">
              <span className="label-text text-sm font-medium text-gray-300">Hook Address (Optional)</span>
            </label>
            <input
              type="text"
              placeholder="0x0000000000000000000000000000000000000000"
              className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100"
              value={hookAddress}
              onChange={(e) => setHookAddress(e.target.value)}
            />
            <p className="mt-1 text-xs text-gray-400">
              Leave as zero address for no hooks. Custom hooks require special handling.
            </p>
          </div>
        )}
        
        {/* Deadline Input - only show for Universal Router */}
        {!directSwapMode && (
          <div className="form-control mb-4">
            <label className="label">
              <span className="label-text text-sm font-medium text-gray-300">Deadline (minutes)</span>
            </label>
            <input
              type="text"
              placeholder="Deadline in minutes"
              className="w-full p-2 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 text-gray-100"
              value={deadline}
              onChange={(e) => setDeadline(e.target.value)}
            />
          </div>
        )}
        
        {/* Action Buttons */}
        <div className="flex flex-col md:flex-row gap-4 mt-6">
          {!directSwapMode ? (
            // Universal Router buttons
            <>
              <button
                className="py-2 px-4 rounded-lg shadow-md transition-all duration-200 flex-1 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white font-medium text-sm"
                onClick={generateCommands}
                disabled={isExecuting}
              >
                {isExecuting ? (
                  <span className="flex items-center justify-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                      Processing...
                  </span>
                ) : "Generate Commands"}
              </button>
              <button
                className="py-2 px-4 rounded-lg shadow-md transition-all duration-200 flex-1 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-medium text-sm"
                disabled={isExecuting}
                onClick={executeSwap}
              >
                {isExecuting ? (
                  <span className="flex items-center justify-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Processing...
                  </span>
                ) : "Execute Swap"}
              </button>
            </>
          ) : (
            // Direct Swap button for Pool Manager
            <button
              className="py-2 px-4 rounded-lg shadow-md transition-all duration-200 w-full bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white font-medium text-sm"
              disabled={isExecuting}
              onClick={executeDirectSwap}
            >
              {isExecuting ? (
                <span className="flex items-center justify-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Processing...
                </span>
              ) : "Execute Direct Swap"}
            </button>
          )}
        </div>
        
        {/* Display Generated Commands - only show for Universal Router */}
        {!directSwapMode && commandsHex && (
          <div className="mt-4 p-4 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 shadow-lg">
            <h3 className="text-md font-medium text-gray-300 mb-2">Generated Command Hex</h3>
            <div className="bg-gray-900/80 rounded-md p-2 overflow-x-auto text-xs text-gray-300 font-mono">
              {commandsHex}
            </div>
            
            {/* Raw Input Data */}
            <h3 className="text-md font-medium text-gray-300 mt-4 mb-2">Raw Input Data</h3>
            <div className="bg-gray-900/80 rounded-md p-2 overflow-x-auto text-xs text-gray-300 font-mono">
              {inputsArray.map((input, index) => (
                <div key={index} className="mb-1 break-all">
                  <span className="text-blue-400 mr-2">Input {index}:</span> {input}
                </div>
              ))}
            </div>
            
            {/* Add Deadline */}
            <h3 className="text-md font-medium text-gray-300 mt-4 mb-2">Transaction Deadline</h3>
            <div className="bg-gray-900/80 rounded-md p-2 text-xs text-gray-300 font-mono">
              <div className="flex justify-between">
                <span className="text-blue-400">Timestamp:</span>
                <span>{generatedCommandsData?.deadline || 0}</span>
              </div>
              <div className="flex justify-between mt-1">
                <span className="text-blue-400">Human readable:</span>
                <span>{generatedCommandsData?.deadline 
                  ? new Date(generatedCommandsData.deadline * 1000).toLocaleString() 
                  : 'Not set'}
                </span>
              </div>
              <div className="flex justify-between mt-1">
                <span className="text-blue-400">Expires in:</span>
                <span>{generatedCommandsData?.deadline 
                  ? `${Math.round((generatedCommandsData.deadline - Math.floor(Date.now() / 1000)) / 60)} minutes` 
                  : 'Not set'}
                </span>
              </div>
            </div>
          </div>
        )}
        
        {/* Add logs display section for direct swap mode after the commands display */}
        {directSwapMode && directSwapLogs.length > 0 && (
          <div className="mt-4 p-4 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 shadow-lg">
            <h3 className="text-md font-medium text-gray-300 mb-2">Direct Swap Logs</h3>
            <div className="bg-gray-900/80 rounded-md p-2 overflow-y-auto max-h-48 text-xs text-gray-300 font-mono">
              {directSwapLogs.map((log, index) => (
                <div key={index} className="mb-1">
                  <span className="text-blue-400">{log}</span>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {/* Display calldata - only show for Universal Router */}
        {!directSwapMode && generatedCommandsData && (
          <div className="mt-4 p-4 rounded-lg bg-gray-800/50 backdrop-blur-sm border border-gray-700 shadow-lg">
            <h3 className="text-md font-medium text-gray-300 mb-2">Full Calldata</h3>
            <div className="bg-gray-900/80 rounded-md p-2 overflow-x-auto text-xs text-gray-300 font-mono break-all">
              {generatedCommandsData.fullCalldata}
            </div>
          </div>
        )}
      </div>
    );
  };

  // Main component render
  return (
    <div className="py-8 px-4 sm:px-0">
      {renderInterface()}
    </div>
  );
} 